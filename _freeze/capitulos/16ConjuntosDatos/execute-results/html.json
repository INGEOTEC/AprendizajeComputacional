{
  "hash": "b7aff9c4c03c6bffb885151ac48ac132",
  "result": {
    "markdown": "# Conjunto de Datos\n\nEl **objetivo** de este apéndice es listar los conjuntos de datos utilizados en el curso.  \n\n## Paquetes usados {.unnumbered}\n\n::: {#25620479 .cell execution_count=1}\n``` {.python .cell-code}\nfrom sklearn.datasets import load_breast_cancer,\\\n                             load_diabetes,\\\n                             load_digits, load_iris,\\\n                             load_wine\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn import decomposition\nfrom scipy.stats import multivariate_normal\nimport umap\nfrom matplotlib import pylab as plt\nimport matplotlib as mpl\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\n```\n:::\n\n\n\n\n## Problemas Sintéticos\n\nEn esta sección se presentan los problemas sintéticos que corresponden aquellos problemas en los que se conocen todos los parámetros y se usan para mostrar algunas características de los algoritmos.\n\n## Mezcla de Clases\n\n::: {#2822abaa .cell execution_count=3}\n``` {.python .cell-code}\np1 = multivariate_normal(mean=[5, 5],\n                         cov=[[4, 0], [0, 2]])\nX_1 = p1.rvs(size=1000)\np2 = multivariate_normal(mean=[1.5, -1.5],\n                         cov=[[2, 1], [1, 3]])\nX_2 = p2.rvs(size=1000)\np3 = multivariate_normal(mean=[12.5, -3.5],\n                         cov=[[2, 3], [3, 7]])\nX_3 = p3.rvs(size=1000)\n```\n:::\n\n\n@fig-gaussian-3classes-app muestra estas tres distribuciones. \n\n::: {#cell-fig-gaussian-3classes-app .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nD = np.concatenate((X_1, X_2, X_3))\nclase = [1] * 1000 + [2] * 1000 + [3] * 1000\nD = np.concatenate((D, np.atleast_2d(clase).T), axis=1)\ndf = pd.DataFrame(D, columns=['x', 'y', 'clase'])\n_ = sns.relplot(data=df, kind='scatter', x='x',\n                palette=PALETTE,\n                y='y', hue='clase')\n```\n\n::: {.cell-output .cell-output-display}\n![Muestras de 3 distribuciones gausianas](16ConjuntosDatos_files/figure-html/fig-gaussian-3classes-app-output-1.png){#fig-gaussian-3classes-app width=536 height=470}\n:::\n:::\n\n\n### Clases Separadas\n\n::: {#b2428b96 .cell execution_count=5}\n``` {.python .cell-code}\nX_1 = multivariate_normal(mean=[5, 5],\n                          cov=[[4, 0], [0, 2]]).rvs(1000)\nX_2 = multivariate_normal(mean=[-5, -10],\n                          cov=[[2, 1], [1, 3]]).rvs(1000)\nX_3 = multivariate_normal(mean=[15, -6],\n                          cov=[[2, 3], [3, 7]]).rvs(1000)\n```\n:::\n\n\nEste problema se muestra en la @fig-gaussian-3classes-app-sep. \n\n::: {#cell-fig-gaussian-3classes-app-sep .cell execution_count=6}\n``` {.python .cell-code code-fold=\"true\"}\nD = np.concatenate((X_1, X_2, X_3))\nclase = [1] * 1000 + [2] * 1000 + [3] * 1000\nD = np.concatenate((D, np.atleast_2d(clase).T), axis=1)\ndf = pd.DataFrame(D, columns=['x', 'y', 'clase'])\n_ = sns.relplot(data=df, kind='scatter', x='x',\n                palette=PALETTE,\n                y='y', hue='clase')\n```\n\n::: {.cell-output .cell-output-display}\n![Muestras de 3 distribuciones gausianas](16ConjuntosDatos_files/figure-html/fig-gaussian-3classes-app-sep-output-1.png){#fig-gaussian-3classes-app-sep width=536 height=470}\n:::\n:::\n\n\n## Problemas de Clasificación\n\nEn esta sección se listan los problemas de clasificación utilizados durante el curso. La @tbl-conjunto-datos-clasificacion resume las principales características de los problemas utilizados. Se incluye la entropía como una media que está relacionada al desbalance de clases, la entropía está normalizada para que su rango se encuentre entre $[0, 1].$\n\n::: {#tbl-conjunto-datos-clasificacion .cell tbl-cap='Problemas de clasificación' execution_count=7}\n\n::: {.cell-output .cell-output-display execution_count=7}\n|Nombre | Tamaño ($N$) | Dimensión ($d$) | Número de clases ($K$)| Entropía |\n|-------|--------------|-----------------|-----------------------|----------|\n|Breast Cancer|$569$|$30$|$2$|0.95|\n|Iris|$150$|$4$|$3$|1.00|\n|Dígitos|$1797$|$64$|$10$|1.00|\n|Vino|$178$|$13$|$3$|0.99|\n\n:::\n:::\n\n\n### Breast Cancer Wisconsin\n\nEl conjunto de datos de Breast Cancer Wisconsin (ver @breast-cancer-wisconsin) se obtiene con el siguiente código. La @fig-conjunto-datos-wisconsin muestra una proyección utilizando PCA de este conjunto de datos. \n\n::: {#d3fc8534 .cell execution_count=8}\n``` {.python .cell-code}\nD, y = load_breast_cancer(return_X_y=True)\n```\n:::\n\n\n::: {#cell-fig-conjunto-datos-wisconsin .cell execution_count=9}\n``` {.python .cell-code code-fold=\"true\"}\nD = StandardScaler().fit_transform(D)\npca = decomposition.PCA(n_components=2).fit(D)\nlow_dim = pca.transform(D)\n# reducer = umap.UMAP(n_neighbors=5)\n# low_dim = reducer.fit_transform(D)\ndf = pd.DataFrame(low_dim, columns=['x', 'y'])\ndf['Clase'] = y\nfig = sns.relplot(df, kind='scatter', \n                  legend='full',  # palette=pal,\n                   x='x', y='y', hue='Clase')\nfig.tick_params(bottom=False, top=False, \n                left=False, right=False,\n                labelbottom=False, labelleft=False)\n_ = fig.set(xlabel=None, ylabel=None)\n```\n\n::: {.cell-output .cell-output-display}\n![Proyección mediante PCA del problema de Breast Cancer Wisconsin.](16ConjuntosDatos_files/figure-html/fig-conjunto-datos-wisconsin-output-1.png){#fig-conjunto-datos-wisconsin width=473 height=432}\n:::\n:::\n\n\n### Iris\n\nUn conjunto clásico en problemas de clasificación es el problema del Iris descrito por @iris; este problema se descarga con la siguiente instrucción. La @fig-conjunto-datos-iris muestra una visualización de estos datos mediante PCA. \n\n::: {#1fd03cfb .cell execution_count=10}\n``` {.python .cell-code}\nD, y = load_iris(return_X_y=True)\n```\n:::\n\n\n::: {#cell-fig-conjunto-datos-iris .cell execution_count=11}\n``` {.python .cell-code code-fold=\"true\"}\nD = StandardScaler().fit_transform(D)\npca = decomposition.PCA(n_components=2).fit(D)\nlow_dim = pca.transform(D)\n# reducer = umap.UMAP(n_neighbors=5)\n# low_dim = reducer.fit_transform(D)\ndf = pd.DataFrame(low_dim, columns=['x', 'y'])\ndf['Clase'] = y\nfig = sns.relplot(df, kind='scatter', \n                  legend='full', palette=PALETTE,\n                   x='x', y='y', hue='Clase')\nfig.tick_params(bottom=False, top=False, \n                left=False, right=False,\n                labelbottom=False, labelleft=False)\n_ = fig.set(xlabel=None, ylabel=None)\n```\n\n::: {.cell-output .cell-output-display}\n![Proyección mediante PCA del problema del Iris.](16ConjuntosDatos_files/figure-html/fig-conjunto-datos-iris-output-1.png){#fig-conjunto-datos-iris width=485 height=432}\n:::\n:::\n\n\n### Dígitos\n\nEl conjunto de Dígitos (ver @digits) es un conjunto de clasificación donde se trata de identificar el número escrito en una imagen; este conjunto de datos se descarga utilizando la siguiente instrucción. La @fig-conjunto-datos-digits muestra una proyección de estos datos utilizando UMAP con ocho vecinos. \n\n::: {#1c4ef8ba .cell execution_count=12}\n``` {.python .cell-code}\nD, y = load_digits(return_X_y=True)\n```\n:::\n\n\n::: {#cell-fig-conjunto-datos-digits .cell execution_count=13}\n``` {.python .cell-code code-fold=\"true\"}\npal = mpl.cm.Paired\nreducer = umap.UMAP(n_neighbors=8)\nD = StandardScaler().fit_transform(D)\nlow_dim = reducer.fit_transform(D)\ndf = pd.DataFrame(low_dim, columns=['x', 'y'])\ndf['Clase'] = y\nfig = sns.relplot(df, kind='scatter', \n                  legend='full', palette=PALETTE,\n                   x='x', y='y', hue='Clase')\nfig.tick_params(bottom=False, top=False, \n                left=False, right=False,\n                labelbottom=False, labelleft=False)\n_ = fig.set(xlabel=None, ylabel=None)\n```\n\n::: {.cell-output .cell-output-display}\n![Proyección mediante UMAP del problema de Dígitos con ocho vecinos.](16ConjuntosDatos_files/figure-html/fig-conjunto-datos-digits-output-1.png){#fig-conjunto-datos-digits width=477 height=432}\n:::\n:::\n\n\n### Vino\n\nEl conjunto de Vino se obtiene con la siguiente instrucción. La @fig-conjunto-datos-wine muestra una proyección de estos datos utilizando PCA. \n\n::: {#1acef05c .cell execution_count=14}\n``` {.python .cell-code}\nD, y = load_wine(return_X_y=True)\n```\n:::\n\n\n::: {#cell-fig-conjunto-datos-wine .cell execution_count=15}\n``` {.python .cell-code code-fold=\"true\"}\npal = mpl.cm.Paired\nD = StandardScaler().fit_transform(D)\npca = decomposition.PCA(n_components=2).fit(D)\nlow_dim = pca.transform(D)\n# reducer = umap.UMAP(n_neighbors=5)\n# low_dim = reducer.fit_transform(D)\ndf = pd.DataFrame(low_dim, columns=['x', 'y'])\ndf['Clase'] = y\nfig = sns.relplot(df, kind='scatter', \n                  legend='full', palette=PALETTE,\n                   x='x', y='y', hue='Clase')\nfig.tick_params(bottom=False, top=False, \n                left=False, right=False,\n                labelbottom=False, labelleft=False)\n_ = fig.set(xlabel=None, ylabel=None)\n```\n\n::: {.cell-output .cell-output-display}\n![Proyección mediante PCA del problema del Vino.](16ConjuntosDatos_files/figure-html/fig-conjunto-datos-wine-output-1.png){#fig-conjunto-datos-wine width=485 height=432}\n:::\n:::\n\n\n## Problemas de Regresión\n\nEn esta sección se listan los problemas de regresión utilizados para ejemplificar los algoritmos y su rendimiento. \n\n### Problema Sintético\n\nEl siguiente ejemplo es un problema de regresión sintético que se forma de la suma de dos funciones trascendentales como se muestra en el siguiente código. \n\n::: {#a8305480 .cell execution_count=16}\n``` {.python .cell-code}\nX = np.linspace(-5, 5, 100)\ny = np.sin(X) + 0.3 * np.cos(X * 3.)\n```\n:::\n\n\nLa @fig-regresion-trascendental muestra este problema sintético.\n\n::: {#cell-fig-regresion-trascendental .cell execution_count=17}\n``` {.python .cell-code code-fold=\"true\"}\ndf = pd.DataFrame(dict(X=X, y=y))\ndf.set_index('X', inplace=True)\nfig = sns.relplot(df, kind='line')\n```\n\n::: {.cell-output .cell-output-display}\n![Problema de Regresión](16ConjuntosDatos_files/figure-html/fig-regresion-trascendental-output-1.png){#fig-regresion-trascendental width=508 height=470}\n:::\n:::\n\n\n### Diabetes\n\nEl conjunto de datos Diabetes es un problema que se puederecuperar usando el siguiente código. \n\n::: {#12b49c1d .cell execution_count=18}\n``` {.python .cell-code}\nD, y = load_diabetes(return_X_y=True)\n```\n:::\n\n\n",
    "supporting": [
      "16ConjuntosDatos_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}