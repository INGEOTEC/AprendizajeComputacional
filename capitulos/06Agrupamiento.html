<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.37">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Aprendizaje Computacional – 6&nbsp; Agrupamiento</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../capitulos/07NoParametricos.html" rel="next">
<link href="../capitulos/05ReduccionDim.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../capitulos/06Agrupamiento.html"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Agrupamiento</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Aprendizaje Computacional</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/INGEOTEC/AprendizajeComputacional" title="Ejecutar el código" class="quarto-navigation-tool px-1" aria-label="Ejecutar el código"><i class="bi bi-github"></i></a>
    <a href="../Aprendizaje-Computacional.pdf" title="Descargar PDF" class="quarto-navigation-tool px-1" aria-label="Descargar PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/01Introduccion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/02Teoria_Decision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Teoría de Decisión Bayesiana</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/03Parametricos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos Paramétricos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/04Rendimiento.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Rendimiento</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/05ReduccionDim.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Reducción de Dimensión</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/06Agrupamiento.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Agrupamiento</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/07NoParametricos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Métodos No Paramétricos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/08Arboles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Árboles de Decisión</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/09Lineal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Discriminantes Lineales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/10Optimizacion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Optimización</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/11RedesNeuronales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Redes Neuronales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/12Ensambles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Ensambles</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/13Comparacion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Comparación de Algoritmos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/17Referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referencias</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Apéndices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/14Estadistica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Estadística</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/15Codigo.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Código</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/16ConjuntosDatos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">C</span>&nbsp; <span class="chapter-title">Conjunto de Datos</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#paquetes-usados" id="toc-paquetes-usados" class="nav-link active" data-scroll-target="#paquetes-usados"><span class="header-section-number">6.1</span> Paquetes usados</a></li>
  <li><a href="#introducción" id="toc-introducción" class="nav-link" data-scroll-target="#introducción"><span class="header-section-number">6.2</span> Introducción</a></li>
  <li><a href="#sec-agrupamiento-k-medias" id="toc-sec-agrupamiento-k-medias" class="nav-link" data-scroll-target="#sec-agrupamiento-k-medias"><span class="header-section-number">6.3</span> K-medias</a>
  <ul class="collapse">
  <li><a href="#mu_i" id="toc-mu_i" class="nav-link" data-scroll-target="#mu_i"><span class="header-section-number">6.3.1</span> <span class="math inline">\(\mu_i\)</span></a></li>
  <li><a href="#g_i" id="toc-g_i" class="nav-link" data-scroll-target="#g_i"><span class="header-section-number">6.3.2</span> <span class="math inline">\(G_i\)</span></a></li>
  <li><a href="#algoritmo" id="toc-algoritmo" class="nav-link" data-scroll-target="#algoritmo"><span class="header-section-number">6.3.3</span> Algoritmo</a></li>
  </ul></li>
  <li><a href="#ejemplo-iris" id="toc-ejemplo-iris" class="nav-link" data-scroll-target="#ejemplo-iris"><span class="header-section-number">6.4</span> Ejemplo: Iris</a></li>
  <li><a href="#rendimiento" id="toc-rendimiento" class="nav-link" data-scroll-target="#rendimiento"><span class="header-section-number">6.5</span> Rendimiento</a></li>
  <li><a href="#número-de-grupos" id="toc-número-de-grupos" class="nav-link" data-scroll-target="#número-de-grupos"><span class="header-section-number">6.6</span> Número de Grupos</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Agrupamiento</span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Código</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Mostrar todo el código</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Ocultar todo el código</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">Ver el código fuente</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>El <strong>objetivo</strong> de la unidad es conocer y aplicar el algoritmo de agrupamiento k-medias</p>
<section id="paquetes-usados" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="paquetes-usados"><span class="header-section-number">6.1</span> Paquetes usados</h2>
<div id="a909b8f1" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> decomposition</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> metrics</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> linalg</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> permutations</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pylab <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div class="quarto-video"><iframe data-external="1" src="https://www.youtube.com/embed/oS_U5XZLS8g" width="560" height="315" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<hr>
</section>
<section id="introducción" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="introducción"><span class="header-section-number">6.2</span> Introducción</h2>
<p>Esta unidad trata el problema de agrupamiento, el cual es un problema de aprendizaje no supervisado (<a href="01Introduccion.html#sec-aprendizaje-no-supervisado" class="quarto-xref"><span>Sección 1.3</span></a>), en el cual se cuenta con un conjunto <span class="math inline">\(\mathcal D = \{ x_i \mid i=1, \ldots, N\}\)</span> donde <span class="math inline">\(x_i \in \mathbb R^d.\)</span> El objetivo de agrupamiento es separar los elementos de <span class="math inline">\(\mathcal D\)</span> en <span class="math inline">\(K\)</span> grupos. Es decir asociar a <span class="math inline">\(x_i \in \mathcal D\)</span> a un grupo <span class="math inline">\(x_i \in G_j\)</span> donde <span class="math inline">\(\cup_j^K G_j = \mathcal D\)</span> y <span class="math inline">\(G_j \cap G_i = \emptyset\)</span> para todo <span class="math inline">\(i \neq j.\)</span></p>
<p>Por supuesto existen diferentes algoritmos que se han desarrollado para generar esta partición, en particular, todos de ellos encuentran la participación optimizando una función objetivo que se considera adecuada para el problema que se está analizando. En particular, esta unidad se enfoca a describir uno de los algoritmos de agrupamiento más utilizados que es K-medias.</p>
</section>
<section id="sec-agrupamiento-k-medias" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="sec-agrupamiento-k-medias"><span class="header-section-number">6.3</span> K-medias</h2>
<p>De manera formal el objetivo de K-medias es encontrar la partición <span class="math inline">\(G = \{G_1, G_2, \ldots, G_K \}\)</span> que corresponda al <span class="math inline">\(\min \sum_{i=1}^K \sum_{x \in G_i} \mid\mid x - \mu_i \mid\mid,\)</span> donde <span class="math inline">\(\mu_i\)</span> es la media de todos los elementos que pertenecen a <span class="math inline">\(G_i.\)</span></p>
<p>Para comprender la función objetivo (<span class="math inline">\(\min \sum_{i=1}^K \sum_{x \in G_i} \mid\mid x - \mu_i \mid\mid\)</span>) de k-medias se explican los dos componentes principales que son las medias <span class="math inline">\(\mu_i\)</span> y los grupos <span class="math inline">\(G_i.\)</span></p>
<p>Para ilustrar tanto a <span class="math inline">\(\mu_i\)</span> como a <span class="math inline">\(G_i\)</span> se utiliza el problema del iris (<a href="05ReduccionDim.html#sec-visualizacion-iris" class="quarto-xref"><span>Sección 5.5.1</span></a>) cuyos datos se pueden obtener de la siguiente manera.</p>
<div id="62c5b446" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>D, y <span class="op">=</span> load_iris(return_X_y<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="mu_i" class="level3" data-number="6.3.1">
<h3 data-number="6.3.1" class="anchored" data-anchor-id="mu_i"><span class="header-section-number">6.3.1</span> <span class="math inline">\(\mu_i\)</span></h3>
<p>Como se describió, <span class="math inline">\(\mu_i\)</span> es la media de los elementos que corresponden al grupo <span class="math inline">\(G_i\)</span>. Asumiendo que el grupo <span class="math inline">\(1\)</span> (<span class="math inline">\(G_1\)</span>) tiene <span class="math inline">\(10\)</span> elementos seleccionados de manera aleatoria de <span class="math inline">\(\mathcal D\)</span> como se muestra a continuación.</p>
<div id="9ab81b96" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> np.arange(<span class="bu">len</span>(D))</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>np.random.shuffle(index)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> index[:<span class="dv">10</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>G_1 <span class="op">=</span> D[sel]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La variable <code>G_1</code> tiene los 10 elementos considerados como miembros de <span class="math inline">\(G_1\)</span> entonces <span class="math inline">\(\mu_1\)</span> se calcula como la media de cada componente, lo cual se puede calcular con el siguiente código.</p>
<div id="c13bef2e" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>mu_1 <span class="op">=</span> G_1.mean(axis<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La <a href="#fig-g1-centro" class="quarto-xref">Figura&nbsp;<span>6.1</span></a> muestra los elementos seleccionados (<span class="math inline">\(x \in G_1\)</span>) y la media (<span class="math inline">\(\mu_1\)</span>) del grupo. Los elementos se encuentran en <span class="math inline">\(\mathbb R^4\)</span> y para visualizarlos se transformaron usando PCA descrito en la <a href="05ReduccionDim.html#sec-visualizacion-iris" class="quarto-xref"><span>Sección 5.5.1</span></a>.</p>
<div id="cell-fig-g1-centro" class="cell" data-execution_count="6">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>Xn <span class="op">=</span> pca.transform(G_1)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> pca.transform(np.atleast_2d(G_1.mean(axis<span class="op">=</span><span class="dv">0</span>)))[<span class="dv">0</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>Xn[:, <span class="dv">0</span>], y<span class="op">=</span>Xn[:, <span class="dv">1</span>], tipo<span class="op">=</span>[<span class="st">'G_1'</span>] <span class="op">*</span> Xn.shape[<span class="dv">0</span>]))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>data.loc[Xn.shape[<span class="dv">0</span>]] <span class="op">=</span> <span class="bu">dict</span>(x<span class="op">=</span>mu[<span class="dv">0</span>], y<span class="op">=</span>mu[<span class="dv">1</span>], tipo<span class="op">=</span><span class="st">'mu_1'</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-g1-centro" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-g1-centro-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="06Agrupamiento_files/figure-html/fig-g1-centro-output-1.png" width="487" height="432" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-g1-centro-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;6.1: Elementos del primer grupo y su centro
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="g_i" class="level3" data-number="6.3.2">
<h3 data-number="6.3.2" class="anchored" data-anchor-id="g_i"><span class="header-section-number">6.3.2</span> <span class="math inline">\(G_i\)</span></h3>
<p>El complemento del procedimiento anterior es encontrar los elementos de <span class="math inline">\(G_i\)</span> dando la <span class="math inline">\(\mu_i\)</span>. El ejemplo consiste en generar dos medias, es decir, <span class="math inline">\(K=2\)</span> y encontrar los elementos que corresponden a las medias generadas. Se puede utilizar cualquier procedimiento para generar dos vectores de manera aleatoria, pero en este ejemplo se asume que estos vectores corresponden a dos elementos de <span class="math inline">\(\mathcal D.\)</span> Estos elementos son los que se encuentran en los indices <span class="math inline">\(50\)</span> y <span class="math inline">\(100\)</span> tal y como se muestra en las siguientes instrucciones.</p>
<div id="874715cb" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>mu_1 <span class="op">=</span> D[<span class="dv">50</span>]</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>mu_2 <span class="op">=</span> D[<span class="dv">100</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El elemento <span class="math inline">\(x\)</span> pertenece al grupo <span class="math inline">\(G_i\)</span> si el valor <span class="math inline">\(\mid\mid x - \mu_i\mid\mid\)</span> corresponde al <span class="math inline">\(\min_j \mid\mid x - \mu_j\mid\mid.\)</span> Entonces se requiere calcular <span class="math inline">\(\mid\mid x - \mu_i\mid\mid\)</span> para cada elemento <span class="math inline">\(x \in \mathcal D\)</span> y para cada una de las medias <span class="math inline">\(\mu_i\)</span>. Esto se puede realizar con la siguiente instrucción</p>
<div id="24d5f000" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>dis <span class="op">=</span> np.array([linalg.norm((D <span class="op">-</span> np.atleast_2d(mu)),</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                            axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> mu <span class="kw">in</span> [mu_1, mu_2]]).T</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>donde se puede observar que el ciclo itera por cada una de las medias, i.e., <code>mu_1</code> y <code>mu_2</code>. Después se calcula la norma utilizando la función <code>linalg.norm</code> y finalmente se regresa la transpuesta para tener una matriz de 150 renglones y dos columnas que corresponden al número de ejemplos en <span class="math inline">\(\mathcal D\)</span> y a las dos medias. Los valores de <code>dis[50]</code> y <code>dis[100]</code> son array([0. , 1.8439]) y array([1.8439, 0. ]) respectivamente. Tal y como se espera porque <span class="math inline">\(\mu_1\)</span> corresponde al índice 50 y <span class="math inline">\(\mu_2\)</span> es el índice 100. Estos dos ejemplos, array([0. , 1.8439]) y array([1.8439, 0. ]), permiten observar que el argumento mínimo de <code>dis</code> identifica al grupo del elemento, haciendo la consideración que el índice 0 representa <span class="math inline">\(G_1\)</span> y el índice 1 es <span class="math inline">\(G_2.\)</span> La siguiente instrucción muestra como se realiza esta asignación.</p>
<div id="78694472" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> dis.argmin(axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La <a href="#fig-k-means-g" class="quarto-xref">Figura&nbsp;<span>6.2</span></a> muestra los grupos formados, el primer grupo <code>G_1</code> se encuentra en azul y el segundo en naranja, también muestra los elementos que fueron usados como medias de cada grupo; estos elementos se observan en color verde.</p>
<div id="cell-fig-k-means-g" class="cell" data-execution_count="10">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>D_pca <span class="op">=</span> pca.transform(D)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame([<span class="bu">dict</span>(x<span class="op">=</span>x, y<span class="op">=</span>y, tipo<span class="op">=</span><span class="ss">f'G_</span><span class="sc">{</span>g<span class="sc">}</span><span class="ss">'</span>) </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                     <span class="cf">for</span> (x, y), g <span class="kw">in</span> <span class="bu">zip</span>(D_pca, G)])</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.vstack((D_pca[<span class="dv">50</span>], D_pca[<span class="dv">100</span>]))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>mu_data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>mu[:, <span class="dv">0</span>], </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>                            y<span class="op">=</span>mu[:, <span class="dv">1</span>],</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>                            tipo<span class="op">=</span>[<span class="st">'mu'</span>] <span class="op">*</span> mu.shape[<span class="dv">0</span>]))</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.concat((data, mu_data))</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-k-means-g" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-k-means-g-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="06Agrupamiento_files/figure-html/fig-k-means-g-output-1.png" width="488" height="428" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-k-means-g-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;6.2: Proyección de los elementos del conjunto y sus centros
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="algoritmo" class="level3" data-number="6.3.3">
<h3 data-number="6.3.3" class="anchored" data-anchor-id="algoritmo"><span class="header-section-number">6.3.3</span> Algoritmo</h3>
<p>Habiendo explicado <span class="math inline">\(\mu_i\)</span> y <span class="math inline">\(G_i\)</span> se procede a describir el procedimiento para calcular los grupos utilizado por k-medias. Este es un procedimiento iterativo que consta de los siguientes pasos.</p>
<ol type="1">
<li>Se generar <span class="math inline">\(K\)</span> medias de manera aleatoria, donde <span class="math inline">\(\mu_i\)</span> corresponde a <span class="math inline">\(G_i.\)</span></li>
<li>Para cada media, <span class="math inline">\(\mu_i\)</span>, se seleccionan los elementos más cercanos, esto es, <span class="math inline">\(x \in G_i\)</span> si <span class="math inline">\(\mid\mid x - \mu_i\mid\mid\)</span> corresponde al <span class="math inline">\(\min_j \mid\mid x - \mu_j\mid\mid.\)</span></li>
<li>Se actualizan las <span class="math inline">\(\mu_i\)</span> con los elementos de <span class="math inline">\(G_i.\)</span></li>
<li>Se regresa al paso 2.</li>
</ol>
<p>El procedimiento termina cuando se llega a un número máximo de iteraciones o que la variación de los <span class="math inline">\(\mu_i\)</span> es mínima, es decir, que los grupos no cambian.</p>
</section>
</section>
<section id="ejemplo-iris" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="ejemplo-iris"><span class="header-section-number">6.4</span> Ejemplo: Iris</h2>
<p>En el siguiente ejemplo se usará K-medias para encontrar 2 y 3 grupos en el conjunto del iris. La clase se inicializa primero con 2 grupos (primera línea). En la segunda instrucción se predice los grupos para todo el conjunto de datos. Las medias para cada grupo se encuentran en el atributo <code>cluster_centers_.</code></p>
<div id="f69c2f13" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">2</span>, n_init<span class="op">=</span><span class="st">'auto'</span>).fit(D)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>cl <span class="op">=</span> m.predict(D)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La <a href="#fig-kmeans-2gr" class="quarto-xref">Figura&nbsp;<span>6.3</span></a> muestra el resultado del algoritmo k-means en el conjunto del Iris, se muestran los dos grupos <span class="math inline">\(G_1\)</span> y <span class="math inline">\(G_2\)</span> y en color verde <span class="math inline">\(\mu_1\)</span> y <span class="math inline">\(\mu_2\)</span>.</p>
<div id="cell-fig-kmeans-2gr" class="cell" data-execution_count="12">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>D_pca <span class="op">=</span> pca.transform(D)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> pca.transform(m.cluster_centers_)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>mu_data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>mu[:, <span class="dv">0</span>],</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>                            y<span class="op">=</span>mu[:, <span class="dv">1</span>],</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>                            tipo<span class="op">=</span>[<span class="st">'mu'</span>] <span class="op">*</span> mu.shape[<span class="dv">0</span>]))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>D_pca[:, <span class="dv">0</span>],</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                         y<span class="op">=</span>D_pca[:, <span class="dv">1</span>],</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>                         tipo<span class="op">=</span>[<span class="ss">f'G_</span><span class="sc">{</span>x<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> cl]))</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.concat((data, mu_data))</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-kmeans-2gr" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-kmeans-2gr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="06Agrupamiento_files/figure-html/fig-kmeans-2gr-output-1.png" width="488" height="428" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-kmeans-2gr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;6.3: Proyección de k-means usando dos grupos
</figcaption>
</figure>
</div>
</div>
</div>
<p>Un procedimiento equivalente se puede realizar para generar tres grupos, el único cambio es el parámetro <code>n_clusters</code> en la clase <code>KMeans</code> de la siguiente manera.</p>
<div id="2f9bbbd4" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">3</span>, n_init<span class="op">=</span><span class="st">'auto'</span>).fit(D)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>cl <span class="op">=</span> m.predict(D)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La <a href="#fig-kmeans-3gr" class="quarto-xref">Figura&nbsp;<span>6.4</span></a> muestra los tres grupos y con sus tres respectivas medias en color rojo.</p>
<div id="cell-fig-kmeans-3gr" class="cell" data-execution_count="14">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>D_pca <span class="op">=</span> pca.transform(D)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> pca.transform(m.cluster_centers_)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>mu_data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>mu[:, <span class="dv">0</span>],</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                            y<span class="op">=</span>mu[:, <span class="dv">1</span>],</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                            tipo<span class="op">=</span>[<span class="st">'mu'</span>] <span class="op">*</span> mu.shape[<span class="dv">0</span>]))</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>D_pca[:, <span class="dv">0</span>],</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                         y<span class="op">=</span>D_pca[:, <span class="dv">1</span>],</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                         tipo<span class="op">=</span>[<span class="ss">f'G_</span><span class="sc">{</span>x<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> cl]))</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.concat((data, mu_data))</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-kmeans-3gr" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-kmeans-3gr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="06Agrupamiento_files/figure-html/fig-kmeans-3gr-output-1.png" width="488" height="428" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-kmeans-3gr-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;6.4: Proyección de k-means usando tres grupos
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="rendimiento" class="level2" data-number="6.5">
<h2 data-number="6.5" class="anchored" data-anchor-id="rendimiento"><span class="header-section-number">6.5</span> Rendimiento</h2>
<p>Recordando que en aprendizaje no supervisado no se tiene una variable dependiente que predecir. En este caso particular se utilizó un problema de clasificación para ilustrar el procedimiento de k-medias, entonces se cuenta con una clase para cada elemento <span class="math inline">\(x \in \mathcal D\)</span>. Además se sabe que el problema del iris tiene tres clases, entonces utilizando los tres grupos obtenidos previamente podemos medir que tanto se parecen estos tres grupos a las clases del iris. Es decir, se puede saber si el algoritmo de k-medias agrupa los elementos de tal manera que cada grupo corresponda a una clase del iris.</p>
<p>Los grupos generados se encuentran en la lista <code>cl</code> y las clases se encuentran en <code>y</code>. La lista <code>y</code> tiene organizada las clases de la siguiente manera: los primeros 50 elementos son la clase <span class="math inline">\(0\)</span>, los siguientes <span class="math inline">\(50\)</span> son clase <span class="math inline">\(1\)</span> y los últimos son la clase <span class="math inline">\(2\)</span>. Dado que K-medias no conoce los clases y genera los grupos empezando de manera aleatoria, entonces es probable que los grupos sigan una numeración diferente al problema del iris. Los grupos en <code>cl</code> están organizados de la siguiente manera aproximadamente los <span class="math inline">\(50\)</span> primeros elementos son del grupo <span class="math inline">\(1\)</span>, los siguientes son grupo <span class="math inline">\(0\)</span> y finalmente los últimos son grupo <span class="math inline">\(2\)</span>. Entonces se puede hacer una transformación usando la variable <code>perm</code> con la siguiente información array([2, 0, 1]).</p>
<p>Utilizando <code>perm</code> se calcula la exactitud (<a href="04Rendimiento.html#sec-accuracy" class="quarto-xref"><span>Sección 4.2.2</span></a>) utilizando la siguiente instrucción. Se obtiene una exactitud de <span class="math inline">\(0.8933\)</span> que significa que la mayoría de los datos se agrupan en un conjunto que corresponde a la clase del conjunto del iris.</p>
<div id="dced2534" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>acc <span class="op">=</span> metrics.accuracy_score(y, perm[cl])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En general en agrupamiento no se cuenta con la composición de los grupos, es más, se desconocen cuántos grupos modela el problema. Para estas ocasiones es imposible medir el accuracy o cualquier otra medida de agrupamiento que requiera la composición de real de los grupos.</p>
<p>Una medida que no requiere conocer los grupos es el <strong>Silhouette Coefficient</strong>; el cual mide la calidad de los grupos, mientras mayor sea el valor significa una mejor calidad en los grupos. Este coeficiente se basa en la siguiente función:</p>
<p><span class="math display">\[
s = \frac{b - a}{\max(a, b)},
\]</span></p>
<p>donde <span class="math inline">\(a\)</span> corresponde a la distancia media entre un elemento y todos las objetos del mismo grupo; y <span class="math inline">\(b\)</span> es la distancia media entre la muestra y todos los elementos del grupo más cercano.</p>
<p>Por ejemplo, en el problema del Iris <span class="math inline">\(s\)</span> tiene un valor de <span class="math inline">\(0.5528\)</span> calculado con la siguiente instrucción.</p>
<div id="e5f6629a" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sil <span class="op">=</span> metrics.silhouette_score(D, cl, metric<span class="op">=</span><span class="st">'euclidean'</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Otra medida de la calidad de los grupos es índice de <strong>Calinski-Harabasz</strong> que mide la dispersión entre grupos y dentro del grupo, al igual que Silhouette, mientras mayor sea la estadística mejor es el agrupamiento. Para el problema del Iris el índice de Calinski-Harabasz tiene un valor de <span class="math inline">\(561.6278\)</span> obtenido con la siguiente instrucción.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>cal_har <span class="op">=</span> metrics.calinski_harabasz_score(D, cl)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="número-de-grupos" class="level2" data-number="6.6">
<h2 data-number="6.6" class="anchored" data-anchor-id="número-de-grupos"><span class="header-section-number">6.6</span> Número de Grupos</h2>
<p>Utilizando una medida de rendimiento de agrupamiento se analizar cual sería el número adecuado de grupos para un problema dado. El procedimiento es variar el número de grupos y medir el rendimiento para cada grupo y quedarse con aquel que da el mejor rendimiento considerando también el número de grupos.</p>
<p>Por ejemplo, el siguiente instrucción calcula el coeficiente de Silhouette y el índice de Calinski-Harabasz en el problema del Iris.</p>
<div id="bbea4b6d" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>S1 <span class="op">=</span> []</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>S2 <span class="op">=</span> []</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">11</span>):</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k, n_init<span class="op">=</span><span class="st">'auto'</span>).fit(D)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    cl <span class="op">=</span> m.predict(D)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> metrics.silhouette_score(D, cl, metric<span class="op">=</span><span class="st">'euclidean'</span>)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    S1.append(_)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> metrics.calinski_harabasz_score(D, cl)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    S2.append(_)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Estas dos estadísticas se pueden observar en la <a href="#fig-k-means-performance-k" class="quarto-xref">Figura&nbsp;<span>6.5</span></a>. En color azul se observa el coeficiente de Silhouette; donde el mejor resultado es cuando <span class="math inline">\(K=2\)</span>. En color naranja se muestra el índice Calinski-Harabasz done el mejor resultado se tiene cuando <span class="math inline">\(K=3\)</span>. Considerando que se está trabajando con el problema del Iris se conoce que la mejor agrupación es para <span class="math inline">\(K=3\)</span> dado que son tres clases.</p>
<div id="cell-fig-k-means-performance-k" class="cell" data-execution_count="21">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame([{<span class="st">'Calinski-Harabasz'</span>: b,  <span class="st">'Silhouette'</span>: a, <span class="st">'K'</span>: k <span class="op">+</span> <span class="dv">2</span>} </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>                     <span class="cf">for</span> k, (a, b) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(S1, S2))])</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>data.set_index(<span class="st">'K'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>sns.lineplot(data<span class="op">=</span>data.Silhouette, color<span class="op">=</span>sns.color_palette()[<span class="dv">0</span>])</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> plt.twinx()</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.lineplot(data<span class="op">=</span>data[<span class="st">'Calinski-Harabasz'</span>], </span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>                   color<span class="op">=</span>sns.color_palette()[<span class="dv">1</span>], ax<span class="op">=</span>ax2)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-k-means-performance-k" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-k-means-performance-k-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="06Agrupamiento_files/figure-html/fig-k-means-performance-k-output-1.png" width="642" height="432" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-k-means-performance-k-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;6.5: Rendimiento variando el número de grupos
</figcaption>
</figure>
</div>
</div>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ingeotec\.github\.io\/AprendizajeComputacional");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../capitulos/05ReduccionDim.html" class="pagination-link" aria-label="Reducción de Dimensión">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Reducción de Dimensión</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../capitulos/07NoParametricos.html" class="pagination-link" aria-label="Métodos No Paramétricos">
        <span class="nav-page-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Métodos No Paramétricos</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Ejecutar el código</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb19" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Agrupamiento</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>El **objetivo** de la unidad es conocer y aplicar el algoritmo de agrupamiento k-medias</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="fu">## Paquetes usados</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> KMeans</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_iris</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> decomposition</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn <span class="im">import</span> metrics</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> linalg</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> itertools <span class="im">import</span> permutations</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pylab <span class="im">as</span> plt</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>np.set_printoptions(precision<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>{{&lt; video https://www.youtube.com/embed/oS_U5XZLS8g width="560" height="315" &gt;}}</span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introducción</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>Esta unidad trata el problema de agrupamiento, el cual es un problema de aprendizaje no supervisado (@sec-aprendizaje-no-supervisado), en el cual se cuenta con un conjunto $\mathcal D = <span class="sc">\{</span> x_i \mid i=1, \ldots, N<span class="sc">\}</span>$ donde $x_i \in \mathbb R^d.$ El objetivo de agrupamiento es separar los elementos de $\mathcal D$ en $K$ grupos. Es decir asociar a $x_i \in \mathcal D$ a un grupo $x_i \in G_j$ donde $\cup_j^K G_j = \mathcal D$ y $G_j \cap G_i = \emptyset$ para todo $i \neq j.$</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>Por supuesto existen diferentes algoritmos que se han desarrollado para generar esta partición, en particular, todos de ellos encuentran la participación optimizando una función objetivo que se considera adecuada para el problema que se está analizando. En particular, esta unidad se enfoca a describir uno de los algoritmos de agrupamiento más utilizados que es K-medias. </span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a><span class="fu">## K-medias {#sec-agrupamiento-k-medias}</span></span>
<span id="cb19-46"><a href="#cb19-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-47"><a href="#cb19-47" aria-hidden="true" tabindex="-1"></a>De manera formal el objetivo de K-medias es encontrar la partición $G = <span class="sc">\{</span>G_1, G_2, \ldots, G_K <span class="sc">\}</span>$ que corresponda al $\min \sum_{i=1}^K \sum_{x \in G_i} \mid\mid x - \mu_i \mid\mid,$ donde $\mu_i$ es la media de todos los elementos que pertenecen a $G_i.$</span>
<span id="cb19-48"><a href="#cb19-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-49"><a href="#cb19-49" aria-hidden="true" tabindex="-1"></a>Para comprender la función objetivo ($\min \sum_{i=1}^K \sum_{x \in G_i} \mid\mid x - \mu_i \mid\mid$) de k-medias se explican los dos componentes principales que son las medias $\mu_i$ y los grupos $G_i.$</span>
<span id="cb19-50"><a href="#cb19-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-51"><a href="#cb19-51" aria-hidden="true" tabindex="-1"></a>Para ilustrar tanto a $\mu_i$ como a $G_i$ se utiliza el problema del iris (@sec-visualizacion-iris) cuyos datos se pueden obtener de la siguiente manera.</span>
<span id="cb19-52"><a href="#cb19-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-55"><a href="#cb19-55" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-56"><a href="#cb19-56" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-57"><a href="#cb19-57" aria-hidden="true" tabindex="-1"></a>D, y <span class="op">=</span> load_iris(return_X_y<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-58"><a href="#cb19-58" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-59"><a href="#cb19-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-60"><a href="#cb19-60" aria-hidden="true" tabindex="-1"></a><span class="fu">### $\mu_i$</span></span>
<span id="cb19-61"><a href="#cb19-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-62"><a href="#cb19-62" aria-hidden="true" tabindex="-1"></a>Como se describió, $\mu_i$ es la media de los elementos que corresponden al grupo $G_i$. Asumiendo que el grupo $1$ ($G_1$) tiene $10$ elementos seleccionados de manera aleatoria de $\mathcal D$ como se muestra a continuación.</span>
<span id="cb19-63"><a href="#cb19-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-66"><a href="#cb19-66" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-67"><a href="#cb19-67" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-68"><a href="#cb19-68" aria-hidden="true" tabindex="-1"></a>index <span class="op">=</span> np.arange(<span class="bu">len</span>(D))</span>
<span id="cb19-69"><a href="#cb19-69" aria-hidden="true" tabindex="-1"></a>np.random.shuffle(index)</span>
<span id="cb19-70"><a href="#cb19-70" aria-hidden="true" tabindex="-1"></a>sel <span class="op">=</span> index[:<span class="dv">10</span>]</span>
<span id="cb19-71"><a href="#cb19-71" aria-hidden="true" tabindex="-1"></a>G_1 <span class="op">=</span> D[sel]</span>
<span id="cb19-72"><a href="#cb19-72" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-73"><a href="#cb19-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-74"><a href="#cb19-74" aria-hidden="true" tabindex="-1"></a>La variable <span class="in">`G_1`</span> tiene los 10 elementos considerados como miembros de $G_1$ entonces $\mu_1$ se calcula como la media de cada componente, lo cual se puede calcular con el siguiente código. </span>
<span id="cb19-75"><a href="#cb19-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-78"><a href="#cb19-78" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-79"><a href="#cb19-79" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-80"><a href="#cb19-80" aria-hidden="true" tabindex="-1"></a>mu_1 <span class="op">=</span> G_1.mean(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb19-81"><a href="#cb19-81" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-82"><a href="#cb19-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-83"><a href="#cb19-83" aria-hidden="true" tabindex="-1"></a>La @fig-g1-centro muestra los elementos seleccionados ($x \in G_1$) y la media ($\mu_1$) del grupo. Los elementos se encuentran en $\mathbb R^4$ y para visualizarlos se transformaron usando PCA descrito en la @sec-visualizacion-iris.</span>
<span id="cb19-84"><a href="#cb19-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-85"><a href="#cb19-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-88"><a href="#cb19-88" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-89"><a href="#cb19-89" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb19-90"><a href="#cb19-90" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Elementos del primer grupo y su centro</span></span>
<span id="cb19-91"><a href="#cb19-91" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-g1-centro</span></span>
<span id="cb19-92"><a href="#cb19-92" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb19-93"><a href="#cb19-93" aria-hidden="true" tabindex="-1"></a>Xn <span class="op">=</span> pca.transform(G_1)</span>
<span id="cb19-94"><a href="#cb19-94" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> pca.transform(np.atleast_2d(G_1.mean(axis<span class="op">=</span><span class="dv">0</span>)))[<span class="dv">0</span>]</span>
<span id="cb19-95"><a href="#cb19-95" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>Xn[:, <span class="dv">0</span>], y<span class="op">=</span>Xn[:, <span class="dv">1</span>], tipo<span class="op">=</span>[<span class="st">'G_1'</span>] <span class="op">*</span> Xn.shape[<span class="dv">0</span>]))</span>
<span id="cb19-96"><a href="#cb19-96" aria-hidden="true" tabindex="-1"></a>data.loc[Xn.shape[<span class="dv">0</span>]] <span class="op">=</span> <span class="bu">dict</span>(x<span class="op">=</span>mu[<span class="dv">0</span>], y<span class="op">=</span>mu[<span class="dv">1</span>], tipo<span class="op">=</span><span class="st">'mu_1'</span>)</span>
<span id="cb19-97"><a href="#cb19-97" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb19-98"><a href="#cb19-98" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb19-99"><a href="#cb19-99" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb19-100"><a href="#cb19-100" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb19-101"><a href="#cb19-101" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb19-102"><a href="#cb19-102" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb19-103"><a href="#cb19-103" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-104"><a href="#cb19-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-105"><a href="#cb19-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-106"><a href="#cb19-106" aria-hidden="true" tabindex="-1"></a><span class="fu">### $G_i$</span></span>
<span id="cb19-107"><a href="#cb19-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-108"><a href="#cb19-108" aria-hidden="true" tabindex="-1"></a>El complemento del procedimiento anterior es encontrar los elementos de $G_i$ dando la $\mu_i$. El ejemplo consiste en generar dos medias, es decir, $K=2$ y encontrar los elementos que corresponden a las medias generadas. Se puede utilizar cualquier procedimiento para generar dos vectores de manera aleatoria, pero en este ejemplo se asume que estos vectores corresponden a dos elementos de $\mathcal D.$ Estos elementos son los que se encuentran en los indices $50$ y $100$ tal y como se muestra en las siguientes instrucciones. </span>
<span id="cb19-109"><a href="#cb19-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-112"><a href="#cb19-112" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-113"><a href="#cb19-113" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-114"><a href="#cb19-114" aria-hidden="true" tabindex="-1"></a>mu_1 <span class="op">=</span> D[<span class="dv">50</span>]</span>
<span id="cb19-115"><a href="#cb19-115" aria-hidden="true" tabindex="-1"></a>mu_2 <span class="op">=</span> D[<span class="dv">100</span>]</span>
<span id="cb19-116"><a href="#cb19-116" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-117"><a href="#cb19-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-118"><a href="#cb19-118" aria-hidden="true" tabindex="-1"></a>El elemento $x$ pertenece al grupo $G_i$ si el valor $\mid\mid x - \mu_i\mid\mid$ corresponde al $\min_j \mid\mid x - \mu_j\mid\mid.$ Entonces se requiere calcular $\mid\mid x - \mu_i\mid\mid$ para cada elemento $x \in \mathcal D$ y para cada una de las medias $\mu_i$. Esto se puede realizar con la siguiente instrucción</span>
<span id="cb19-119"><a href="#cb19-119" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-122"><a href="#cb19-122" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-123"><a href="#cb19-123" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-124"><a href="#cb19-124" aria-hidden="true" tabindex="-1"></a>dis <span class="op">=</span> np.array([linalg.norm((D <span class="op">-</span> np.atleast_2d(mu)),</span>
<span id="cb19-125"><a href="#cb19-125" aria-hidden="true" tabindex="-1"></a>                            axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-126"><a href="#cb19-126" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> mu <span class="kw">in</span> [mu_1, mu_2]]).T</span>
<span id="cb19-127"><a href="#cb19-127" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-128"><a href="#cb19-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-129"><a href="#cb19-129" aria-hidden="true" tabindex="-1"></a>donde se puede observar que el ciclo itera por cada una de las medias, i.e., <span class="in">`mu_1`</span> y <span class="in">`mu_2`</span>. Después se calcula la norma utilizando la función <span class="in">`linalg.norm`</span> y finalmente se regresa la transpuesta para tener una matriz de 150 renglones y dos columnas que corresponden al número de ejemplos en $\mathcal D$ y a las dos medias. Los valores de <span class="in">`dis[50]`</span> y <span class="in">`dis[100]`</span> son <span class="in">`{python} dis[50]`</span> y <span class="in">`{python} dis[100]`</span> respectivamente. Tal y como se espera porque $\mu_1$ corresponde al índice 50 y $\mu_2$ es el índice 100. Estos dos ejemplos, <span class="in">`{python} dis[50]`</span> y <span class="in">`{python} dis[100]`</span>, permiten observar que el argumento mínimo de <span class="in">`dis`</span> identifica al grupo del elemento, haciendo la consideración que el índice 0 representa $G_1$ y el índice 1 es $G_2.$ La siguiente instrucción muestra como se realiza esta asignación. </span>
<span id="cb19-130"><a href="#cb19-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-133"><a href="#cb19-133" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-134"><a href="#cb19-134" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-135"><a href="#cb19-135" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> dis.argmin(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb19-136"><a href="#cb19-136" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-137"><a href="#cb19-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-138"><a href="#cb19-138" aria-hidden="true" tabindex="-1"></a>La @fig-k-means-g muestra los grupos formados, el primer grupo <span class="in">`G_1`</span> se encuentra en azul y el segundo en naranja, también muestra los elementos que fueron usados como medias de cada grupo; estos elementos se observan en color verde. </span>
<span id="cb19-139"><a href="#cb19-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-140"><a href="#cb19-140" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-143"><a href="#cb19-143" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-144"><a href="#cb19-144" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb19-145"><a href="#cb19-145" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Proyección de los elementos del conjunto y sus centros</span></span>
<span id="cb19-146"><a href="#cb19-146" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-k-means-g</span></span>
<span id="cb19-147"><a href="#cb19-147" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb19-148"><a href="#cb19-148" aria-hidden="true" tabindex="-1"></a>D_pca <span class="op">=</span> pca.transform(D)</span>
<span id="cb19-149"><a href="#cb19-149" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame([<span class="bu">dict</span>(x<span class="op">=</span>x, y<span class="op">=</span>y, tipo<span class="op">=</span><span class="ss">f'G_</span><span class="sc">{</span>g<span class="sc">}</span><span class="ss">'</span>) </span>
<span id="cb19-150"><a href="#cb19-150" aria-hidden="true" tabindex="-1"></a>                     <span class="cf">for</span> (x, y), g <span class="kw">in</span> <span class="bu">zip</span>(D_pca, G)])</span>
<span id="cb19-151"><a href="#cb19-151" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.vstack((D_pca[<span class="dv">50</span>], D_pca[<span class="dv">100</span>]))</span>
<span id="cb19-152"><a href="#cb19-152" aria-hidden="true" tabindex="-1"></a>mu_data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>mu[:, <span class="dv">0</span>], </span>
<span id="cb19-153"><a href="#cb19-153" aria-hidden="true" tabindex="-1"></a>                            y<span class="op">=</span>mu[:, <span class="dv">1</span>],</span>
<span id="cb19-154"><a href="#cb19-154" aria-hidden="true" tabindex="-1"></a>                            tipo<span class="op">=</span>[<span class="st">'mu'</span>] <span class="op">*</span> mu.shape[<span class="dv">0</span>]))</span>
<span id="cb19-155"><a href="#cb19-155" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.concat((data, mu_data))</span>
<span id="cb19-156"><a href="#cb19-156" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb19-157"><a href="#cb19-157" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb19-158"><a href="#cb19-158" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb19-159"><a href="#cb19-159" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb19-160"><a href="#cb19-160" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb19-161"><a href="#cb19-161" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb19-162"><a href="#cb19-162" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-163"><a href="#cb19-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-164"><a href="#cb19-164" aria-hidden="true" tabindex="-1"></a><span class="fu">### Algoritmo</span></span>
<span id="cb19-165"><a href="#cb19-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-166"><a href="#cb19-166" aria-hidden="true" tabindex="-1"></a>Habiendo explicado $\mu_i$ y $G_i$ se procede a describir el procedimiento para calcular los grupos utilizado por k-medias. Este es un procedimiento iterativo que consta de los siguientes pasos. </span>
<span id="cb19-167"><a href="#cb19-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-168"><a href="#cb19-168" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Se generar $K$ medias de manera aleatoria, donde $\mu_i$ corresponde a $G_i.$</span>
<span id="cb19-169"><a href="#cb19-169" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Para cada media, $\mu_i$, se seleccionan los elementos más cercanos, esto es, $x \in G_i$ si $\mid\mid x - \mu_i\mid\mid$ corresponde al $\min_j \mid\mid x - \mu_j\mid\mid.$</span>
<span id="cb19-170"><a href="#cb19-170" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Se actualizan las $\mu_i$ con los elementos de $G_i.$</span>
<span id="cb19-171"><a href="#cb19-171" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Se regresa al paso 2. </span>
<span id="cb19-172"><a href="#cb19-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-173"><a href="#cb19-173" aria-hidden="true" tabindex="-1"></a>El procedimiento termina cuando se llega a un número máximo de iteraciones o que la variación de los $\mu_i$ es mínima, es decir, que los grupos no cambian. </span>
<span id="cb19-174"><a href="#cb19-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-175"><a href="#cb19-175" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ejemplo: Iris</span></span>
<span id="cb19-176"><a href="#cb19-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-177"><a href="#cb19-177" aria-hidden="true" tabindex="-1"></a>En el siguiente ejemplo se usará K-medias para encontrar 2 y 3 grupos en el conjunto del iris. La clase se inicializa primero con 2 grupos (primera línea). En la segunda instrucción se predice los grupos para todo el conjunto de datos. Las medias para cada grupo se encuentran en el atributo <span class="in">`cluster_centers_.`</span></span>
<span id="cb19-178"><a href="#cb19-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-181"><a href="#cb19-181" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-182"><a href="#cb19-182" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-183"><a href="#cb19-183" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">2</span>, n_init<span class="op">=</span><span class="st">'auto'</span>).fit(D)</span>
<span id="cb19-184"><a href="#cb19-184" aria-hidden="true" tabindex="-1"></a>cl <span class="op">=</span> m.predict(D)</span>
<span id="cb19-185"><a href="#cb19-185" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-186"><a href="#cb19-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-187"><a href="#cb19-187" aria-hidden="true" tabindex="-1"></a>La @fig-kmeans-2gr muestra el resultado del algoritmo k-means en el conjunto del Iris, se muestran los dos grupos $G_1$ y $G_2$ y en color verde $\mu_1$ y $\mu_2$. </span>
<span id="cb19-188"><a href="#cb19-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-191"><a href="#cb19-191" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-192"><a href="#cb19-192" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb19-193"><a href="#cb19-193" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Proyección de k-means usando dos grupos</span></span>
<span id="cb19-194"><a href="#cb19-194" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-kmeans-2gr</span></span>
<span id="cb19-195"><a href="#cb19-195" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb19-196"><a href="#cb19-196" aria-hidden="true" tabindex="-1"></a>D_pca <span class="op">=</span> pca.transform(D)</span>
<span id="cb19-197"><a href="#cb19-197" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> pca.transform(m.cluster_centers_)</span>
<span id="cb19-198"><a href="#cb19-198" aria-hidden="true" tabindex="-1"></a>mu_data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>mu[:, <span class="dv">0</span>],</span>
<span id="cb19-199"><a href="#cb19-199" aria-hidden="true" tabindex="-1"></a>                            y<span class="op">=</span>mu[:, <span class="dv">1</span>],</span>
<span id="cb19-200"><a href="#cb19-200" aria-hidden="true" tabindex="-1"></a>                            tipo<span class="op">=</span>[<span class="st">'mu'</span>] <span class="op">*</span> mu.shape[<span class="dv">0</span>]))</span>
<span id="cb19-201"><a href="#cb19-201" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>D_pca[:, <span class="dv">0</span>],</span>
<span id="cb19-202"><a href="#cb19-202" aria-hidden="true" tabindex="-1"></a>                         y<span class="op">=</span>D_pca[:, <span class="dv">1</span>],</span>
<span id="cb19-203"><a href="#cb19-203" aria-hidden="true" tabindex="-1"></a>                         tipo<span class="op">=</span>[<span class="ss">f'G_</span><span class="sc">{</span>x<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> cl]))</span>
<span id="cb19-204"><a href="#cb19-204" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.concat((data, mu_data))</span>
<span id="cb19-205"><a href="#cb19-205" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb19-206"><a href="#cb19-206" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb19-207"><a href="#cb19-207" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb19-208"><a href="#cb19-208" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb19-209"><a href="#cb19-209" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb19-210"><a href="#cb19-210" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb19-211"><a href="#cb19-211" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-212"><a href="#cb19-212" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-213"><a href="#cb19-213" aria-hidden="true" tabindex="-1"></a>Un procedimiento equivalente se puede realizar para generar </span>
<span id="cb19-214"><a href="#cb19-214" aria-hidden="true" tabindex="-1"></a>tres grupos, el único cambio es el parámetro <span class="in">`n_clusters`</span></span>
<span id="cb19-215"><a href="#cb19-215" aria-hidden="true" tabindex="-1"></a>en la clase <span class="in">`KMeans`</span> de la siguiente manera.</span>
<span id="cb19-216"><a href="#cb19-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-219"><a href="#cb19-219" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-220"><a href="#cb19-220" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-221"><a href="#cb19-221" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> KMeans(n_clusters<span class="op">=</span><span class="dv">3</span>, n_init<span class="op">=</span><span class="st">'auto'</span>).fit(D)</span>
<span id="cb19-222"><a href="#cb19-222" aria-hidden="true" tabindex="-1"></a>cl <span class="op">=</span> m.predict(D)</span>
<span id="cb19-223"><a href="#cb19-223" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-224"><a href="#cb19-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-225"><a href="#cb19-225" aria-hidden="true" tabindex="-1"></a>La @fig-kmeans-3gr muestra los tres grupos y con sus tres respectivas medias en color rojo. </span>
<span id="cb19-226"><a href="#cb19-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-227"><a href="#cb19-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-230"><a href="#cb19-230" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-231"><a href="#cb19-231" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb19-232"><a href="#cb19-232" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Proyección de k-means usando tres grupos</span></span>
<span id="cb19-233"><a href="#cb19-233" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-kmeans-3gr</span></span>
<span id="cb19-234"><a href="#cb19-234" aria-hidden="true" tabindex="-1"></a>pca <span class="op">=</span> decomposition.PCA(n_components<span class="op">=</span><span class="dv">2</span>).fit(D)</span>
<span id="cb19-235"><a href="#cb19-235" aria-hidden="true" tabindex="-1"></a>D_pca <span class="op">=</span> pca.transform(D)</span>
<span id="cb19-236"><a href="#cb19-236" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> pca.transform(m.cluster_centers_)</span>
<span id="cb19-237"><a href="#cb19-237" aria-hidden="true" tabindex="-1"></a>mu_data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>mu[:, <span class="dv">0</span>],</span>
<span id="cb19-238"><a href="#cb19-238" aria-hidden="true" tabindex="-1"></a>                            y<span class="op">=</span>mu[:, <span class="dv">1</span>],</span>
<span id="cb19-239"><a href="#cb19-239" aria-hidden="true" tabindex="-1"></a>                            tipo<span class="op">=</span>[<span class="st">'mu'</span>] <span class="op">*</span> mu.shape[<span class="dv">0</span>]))</span>
<span id="cb19-240"><a href="#cb19-240" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(x<span class="op">=</span>D_pca[:, <span class="dv">0</span>],</span>
<span id="cb19-241"><a href="#cb19-241" aria-hidden="true" tabindex="-1"></a>                         y<span class="op">=</span>D_pca[:, <span class="dv">1</span>],</span>
<span id="cb19-242"><a href="#cb19-242" aria-hidden="true" tabindex="-1"></a>                         tipo<span class="op">=</span>[<span class="ss">f'G_</span><span class="sc">{</span>x<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> cl]))</span>
<span id="cb19-243"><a href="#cb19-243" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.concat((data, mu_data))</span>
<span id="cb19-244"><a href="#cb19-244" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb19-245"><a href="#cb19-245" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.relplot(data, kind<span class="op">=</span><span class="st">'scatter'</span>, hue<span class="op">=</span><span class="st">'tipo'</span>, x<span class="op">=</span><span class="st">'x'</span>, y<span class="op">=</span><span class="st">'y'</span>)</span>
<span id="cb19-246"><a href="#cb19-246" aria-hidden="true" tabindex="-1"></a>fig.tick_params(bottom<span class="op">=</span><span class="va">False</span>, top<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb19-247"><a href="#cb19-247" aria-hidden="true" tabindex="-1"></a>                left<span class="op">=</span><span class="va">False</span>, right<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb19-248"><a href="#cb19-248" aria-hidden="true" tabindex="-1"></a>                labelbottom<span class="op">=</span><span class="va">False</span>, labelleft<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb19-249"><a href="#cb19-249" aria-hidden="true" tabindex="-1"></a>fig.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="va">None</span>, ylabel<span class="op">=</span><span class="va">None</span>)</span>
<span id="cb19-250"><a href="#cb19-250" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-251"><a href="#cb19-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-252"><a href="#cb19-252" aria-hidden="true" tabindex="-1"></a><span class="fu">## Rendimiento</span></span>
<span id="cb19-253"><a href="#cb19-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-254"><a href="#cb19-254" aria-hidden="true" tabindex="-1"></a>Recordando que en aprendizaje no supervisado no se tiene una variable dependiente que predecir. En este caso particular se utilizó un problema de clasificación para ilustrar el procedimiento de k-medias, entonces se cuenta con una clase para cada elemento $x \in \mathcal D$. Además se sabe que el problema del iris tiene tres clases, entonces utilizando los tres grupos obtenidos previamente podemos medir que tanto se parecen estos tres grupos a las clases del iris. Es decir, se puede saber si el algoritmo de k-medias agrupa los elementos de tal manera que cada grupo corresponda a una clase del iris. </span>
<span id="cb19-255"><a href="#cb19-255" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-258"><a href="#cb19-258" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-259"><a href="#cb19-259" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb19-260"><a href="#cb19-260" aria-hidden="true" tabindex="-1"></a>perms <span class="op">=</span> <span class="bu">list</span>(permutations([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]))</span>
<span id="cb19-261"><a href="#cb19-261" aria-hidden="true" tabindex="-1"></a>perfs <span class="op">=</span> [(metrics.accuracy_score(y, np.array(x)[cl]), x)</span>
<span id="cb19-262"><a href="#cb19-262" aria-hidden="true" tabindex="-1"></a>         <span class="cf">for</span> x <span class="kw">in</span> perms]</span>
<span id="cb19-263"><a href="#cb19-263" aria-hidden="true" tabindex="-1"></a>perm <span class="op">=</span> np.r_[<span class="bu">sorted</span>(perfs, key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>])[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>]]</span>
<span id="cb19-264"><a href="#cb19-264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-265"><a href="#cb19-265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-266"><a href="#cb19-266" aria-hidden="true" tabindex="-1"></a>Los grupos generados se encuentran en la lista <span class="in">`cl`</span> y las clases se encuentran en <span class="in">`y`</span>. La lista <span class="in">`y`</span> tiene organizada las clases de la siguiente manera: los primeros 50 elementos son la clase $0$, los siguientes $50$ son clase $1$ y los últimos son la clase $2$. Dado que K-medias no conoce los clases y genera los grupos empezando de manera aleatoria, entonces es probable que los grupos sigan una numeración diferente al problema del iris. Los grupos en <span class="in">`cl`</span> están organizados de la siguiente manera aproximadamente los $50$ primeros elementos son del grupo $1$, los siguientes son grupo $0$ y finalmente los últimos son grupo $2$. Entonces se puede hacer una transformación usando la variable <span class="in">`perm`</span> con la siguiente información <span class="in">`{python} perm`</span>.</span>
<span id="cb19-267"><a href="#cb19-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-270"><a href="#cb19-270" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-271"><a href="#cb19-271" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb19-272"><a href="#cb19-272" aria-hidden="true" tabindex="-1"></a>acc_f <span class="op">=</span> Markdown(<span class="ss">f'$</span><span class="sc">{</span>metrics<span class="sc">.</span>accuracy_score(y, perm[cl])<span class="sc">:0.4f}</span><span class="ss">$'</span>)</span>
<span id="cb19-273"><a href="#cb19-273" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-274"><a href="#cb19-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-275"><a href="#cb19-275" aria-hidden="true" tabindex="-1"></a>Utilizando <span class="in">`perm`</span> se calcula la exactitud (@sec-accuracy) utilizando la siguiente instrucción. Se obtiene una exactitud de <span class="in">`{python} acc_f`</span> que significa que la mayoría de los datos se agrupan en un conjunto que corresponde a la clase del conjunto del iris. </span>
<span id="cb19-276"><a href="#cb19-276" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-279"><a href="#cb19-279" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-280"><a href="#cb19-280" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-281"><a href="#cb19-281" aria-hidden="true" tabindex="-1"></a>acc <span class="op">=</span> metrics.accuracy_score(y, perm[cl])</span>
<span id="cb19-282"><a href="#cb19-282" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-283"><a href="#cb19-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-284"><a href="#cb19-284" aria-hidden="true" tabindex="-1"></a>En general en agrupamiento no se cuenta con la composición de los grupos, es más, se desconocen cuántos grupos modela el problema. Para estas ocasiones es imposible medir el accuracy o cualquier otra medida de agrupamiento que requiera la composición de real de los grupos. </span>
<span id="cb19-285"><a href="#cb19-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-286"><a href="#cb19-286" aria-hidden="true" tabindex="-1"></a>Una medida que no requiere conocer los grupos es el **Silhouette Coefficient**; el cual mide la calidad de los grupos, mientras mayor sea el valor significa una mejor calidad en los grupos. Este coeficiente se basa en la siguiente función:</span>
<span id="cb19-287"><a href="#cb19-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-288"><a href="#cb19-288" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-289"><a href="#cb19-289" aria-hidden="true" tabindex="-1"></a>s = \frac{b - a}{\max(a, b)},</span>
<span id="cb19-290"><a href="#cb19-290" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb19-291"><a href="#cb19-291" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-292"><a href="#cb19-292" aria-hidden="true" tabindex="-1"></a>donde $a$ corresponde a la distancia media entre un elemento y todos las objetos del mismo grupo; y $b$ es la distancia media entre la muestra y todos los elementos del grupo más cercano.</span>
<span id="cb19-293"><a href="#cb19-293" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-296"><a href="#cb19-296" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-297"><a href="#cb19-297" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb19-298"><a href="#cb19-298" aria-hidden="true" tabindex="-1"></a>sil_f <span class="op">=</span> <span class="ss">f'$</span><span class="sc">{</span>metrics<span class="sc">.</span>silhouette_score(D, cl, metric<span class="op">=</span><span class="st">"euclidean"</span>)<span class="sc">:0.4f}</span><span class="ss">$'</span></span>
<span id="cb19-299"><a href="#cb19-299" aria-hidden="true" tabindex="-1"></a>sil_f <span class="op">=</span> Markdown(sil_f)</span>
<span id="cb19-300"><a href="#cb19-300" aria-hidden="true" tabindex="-1"></a>cal_har_f <span class="op">=</span> metrics.calinski_harabasz_score(D, cl)</span>
<span id="cb19-301"><a href="#cb19-301" aria-hidden="true" tabindex="-1"></a>cal_har_f <span class="op">=</span> Markdown(<span class="ss">f'$</span><span class="sc">{</span>cal_har_f<span class="sc">:0.4f}</span><span class="ss">$'</span>)</span>
<span id="cb19-302"><a href="#cb19-302" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-303"><a href="#cb19-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-304"><a href="#cb19-304" aria-hidden="true" tabindex="-1"></a>Por ejemplo, en el problema del Iris $s$ tiene un valor de <span class="in">`{python} sil_f`</span> calculado con la siguiente instrucción. </span>
<span id="cb19-305"><a href="#cb19-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-308"><a href="#cb19-308" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-309"><a href="#cb19-309" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-310"><a href="#cb19-310" aria-hidden="true" tabindex="-1"></a>sil <span class="op">=</span> metrics.silhouette_score(D, cl, metric<span class="op">=</span><span class="st">'euclidean'</span>)</span>
<span id="cb19-311"><a href="#cb19-311" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-312"><a href="#cb19-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-313"><a href="#cb19-313" aria-hidden="true" tabindex="-1"></a>Otra medida de la calidad de los grupos es índice de **Calinski-Harabasz** que mide la dispersión entre grupos y dentro del grupo, al igual que Silhouette, mientras mayor sea la estadística mejor es el agrupamiento. Para el problema del Iris el índice de Calinski-Harabasz tiene un valor de <span class="in">`{python} cal_har_f`</span> obtenido con la siguiente instrucción.</span>
<span id="cb19-314"><a href="#cb19-314" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-315"><a href="#cb19-315" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb19-316"><a href="#cb19-316" aria-hidden="true" tabindex="-1"></a>cal_har <span class="op">=</span> metrics.calinski_harabasz_score(D, cl)</span>
<span id="cb19-317"><a href="#cb19-317" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-318"><a href="#cb19-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-319"><a href="#cb19-319" aria-hidden="true" tabindex="-1"></a><span class="fu">## Número de Grupos</span></span>
<span id="cb19-320"><a href="#cb19-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-321"><a href="#cb19-321" aria-hidden="true" tabindex="-1"></a>Utilizando una medida de rendimiento de agrupamiento se analizar cual sería el número adecuado de grupos para un problema dado. El procedimiento es variar el número de grupos y medir el rendimiento para cada grupo y quedarse con aquel que da el mejor rendimiento considerando también el número de grupos. </span>
<span id="cb19-322"><a href="#cb19-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-323"><a href="#cb19-323" aria-hidden="true" tabindex="-1"></a>Por ejemplo, el siguiente instrucción calcula el coeficiente de Silhouette y el índice de Calinski-Harabasz en el problema del Iris. </span>
<span id="cb19-324"><a href="#cb19-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-327"><a href="#cb19-327" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-328"><a href="#cb19-328" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb19-329"><a href="#cb19-329" aria-hidden="true" tabindex="-1"></a>S1 <span class="op">=</span> []</span>
<span id="cb19-330"><a href="#cb19-330" aria-hidden="true" tabindex="-1"></a>S2 <span class="op">=</span> []</span>
<span id="cb19-331"><a href="#cb19-331" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">11</span>):</span>
<span id="cb19-332"><a href="#cb19-332" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> KMeans(n_clusters<span class="op">=</span>k, n_init<span class="op">=</span><span class="st">'auto'</span>).fit(D)</span>
<span id="cb19-333"><a href="#cb19-333" aria-hidden="true" tabindex="-1"></a>    cl <span class="op">=</span> m.predict(D)</span>
<span id="cb19-334"><a href="#cb19-334" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> metrics.silhouette_score(D, cl, metric<span class="op">=</span><span class="st">'euclidean'</span>)</span>
<span id="cb19-335"><a href="#cb19-335" aria-hidden="true" tabindex="-1"></a>    S1.append(_)</span>
<span id="cb19-336"><a href="#cb19-336" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> metrics.calinski_harabasz_score(D, cl)</span>
<span id="cb19-337"><a href="#cb19-337" aria-hidden="true" tabindex="-1"></a>    S2.append(_)</span>
<span id="cb19-338"><a href="#cb19-338" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb19-339"><a href="#cb19-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-340"><a href="#cb19-340" aria-hidden="true" tabindex="-1"></a>Estas dos estadísticas se pueden observar en la @fig-k-means-performance-k. En color azul se observa el coeficiente de Silhouette; donde el mejor resultado es cuando $K=2$. En color naranja se muestra el índice Calinski-Harabasz done el mejor resultado se tiene cuando $K=3$. Considerando que se está trabajando con el problema del Iris se conoce que la mejor agrupación es para $K=3$ dado que son tres clases.</span>
<span id="cb19-341"><a href="#cb19-341" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-344"><a href="#cb19-344" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb19-345"><a href="#cb19-345" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb19-346"><a href="#cb19-346" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Rendimiento variando el número de grupos</span></span>
<span id="cb19-347"><a href="#cb19-347" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-k-means-performance-k</span></span>
<span id="cb19-348"><a href="#cb19-348" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> pd.DataFrame([{<span class="st">'Calinski-Harabasz'</span>: b,  <span class="st">'Silhouette'</span>: a, <span class="st">'K'</span>: k <span class="op">+</span> <span class="dv">2</span>} </span>
<span id="cb19-349"><a href="#cb19-349" aria-hidden="true" tabindex="-1"></a>                     <span class="cf">for</span> k, (a, b) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(S1, S2))])</span>
<span id="cb19-350"><a href="#cb19-350" aria-hidden="true" tabindex="-1"></a>data.set_index(<span class="st">'K'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb19-351"><a href="#cb19-351" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb19-352"><a href="#cb19-352" aria-hidden="true" tabindex="-1"></a>sns.lineplot(data<span class="op">=</span>data.Silhouette, color<span class="op">=</span>sns.color_palette()[<span class="dv">0</span>])</span>
<span id="cb19-353"><a href="#cb19-353" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> plt.twinx()</span>
<span id="cb19-354"><a href="#cb19-354" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.lineplot(data<span class="op">=</span>data[<span class="st">'Calinski-Harabasz'</span>], </span>
<span id="cb19-355"><a href="#cb19-355" aria-hidden="true" tabindex="-1"></a>                   color<span class="op">=</span>sns.color_palette()[<span class="dv">1</span>], ax<span class="op">=</span>ax2)</span>
<span id="cb19-356"><a href="#cb19-356" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copiar al portapapeles" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" class="img-fluid"></a> <br> Esta obra está bajo una <a href="http://creativecommons.org/licenses/by-sa/4.0/">Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional</a></p>
</div>
  </div>
</footer>




</body></html>