<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Métodos Paramétricos – Aprendizaje Computacional</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../capitulos/04Rendimiento.html" rel="next">
<link href="../capitulos/02Teoria_Decision.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-a34d670291f06f286357e447776a572a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../capitulos/03Parametricos.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos Paramétricos</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Alternar barra lateral" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Buscar" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Aprendizaje Computacional</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/INGEOTEC/AprendizajeComputacional" title="Ejecutar el código" class="quarto-navigation-tool px-1" aria-label="Ejecutar el código"><i class="bi bi-github"></i></a>
    <a href="../Aprendizaje-Computacional.pdf" title="Descargar PDF" class="quarto-navigation-tool px-1" aria-label="Descargar PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Buscar"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Prefacio</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/01Introduccion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introducción</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/02Teoria_Decision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Teoría de Decisión Bayesiana</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/03Parametricos.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos Paramétricos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/04Rendimiento.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Rendimiento</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/05ReduccionDim.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Reducción de Dimensión</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/06Agrupamiento.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Agrupamiento</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/07NoParametricos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Métodos No Paramétricos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/08Arboles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Árboles de Decisión</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/09Lineal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Discriminantes Lineales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/10Optimizacion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Optimización</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/11RedesNeuronales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Redes Neuronales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/12Ensambles.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Ensambles</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/13Comparacion.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Comparación de Algoritmos</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/17Referencias.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Referencias</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Apéndices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Alternar sección">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/14Estadistica.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">Estadística</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../capitulos/16ConjuntosDatos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">B</span>&nbsp; <span class="chapter-title">Conjunto de Datos</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de contenidos</h2>
   
  <ul>
  <li><a href="#paquetes-usados" id="toc-paquetes-usados" class="nav-link active" data-scroll-target="#paquetes-usados">Paquetes usados</a></li>
  <li><a href="#sec-intro-03" id="toc-sec-intro-03" class="nav-link" data-scroll-target="#sec-intro-03"><span class="header-section-number">3.1</span> Introducción</a></li>
  <li><a href="#sec-metodologia-met-parametricos" id="toc-sec-metodologia-met-parametricos" class="nav-link" data-scroll-target="#sec-metodologia-met-parametricos"><span class="header-section-number">3.2</span> Metodología</a></li>
  <li><a href="#sec-estimacion-parametros-gnal" id="toc-sec-estimacion-parametros-gnal" class="nav-link" data-scroll-target="#sec-estimacion-parametros-gnal"><span class="header-section-number">3.3</span> Estimación de Parámetros</a>
  <ul class="collapse">
  <li><a href="#sec-verosimilitud" id="toc-sec-verosimilitud" class="nav-link" data-scroll-target="#sec-verosimilitud"><span class="header-section-number">3.3.1</span> Verosimilitud</a></li>
  <li><a href="#sec-distribucción-de-bernoulli" id="toc-sec-distribucción-de-bernoulli" class="nav-link" data-scroll-target="#sec-distribucción-de-bernoulli"><span class="header-section-number">3.3.2</span> Distribución de Bernoulli</a></li>
  <li><a href="#sec-estimacion-distribucion-gausiana" id="toc-sec-estimacion-distribucion-gausiana" class="nav-link" data-scroll-target="#sec-estimacion-distribucion-gausiana"><span class="header-section-number">3.3.3</span> Ejemplo: Distribución Gausiana</a></li>
  </ul></li>
  <li><a href="#metodología-de-clasificación" id="toc-metodología-de-clasificación" class="nav-link" data-scroll-target="#metodología-de-clasificación"><span class="header-section-number">3.4</span> Metodología de Clasificación</a></li>
  <li><a href="#sec-conjunto-entre-prueba" id="toc-sec-conjunto-entre-prueba" class="nav-link" data-scroll-target="#sec-conjunto-entre-prueba"><span class="header-section-number">3.5</span> Conjunto de Entrenamiento y Prueba</a></li>
  <li><a href="#sec-model-clasificacion" id="toc-sec-model-clasificacion" class="nav-link" data-scroll-target="#sec-model-clasificacion"><span class="header-section-number">3.6</span> Clasificador</a>
  <ul class="collapse">
  <li><a href="#sec-estimacion-parametros" id="toc-sec-estimacion-parametros" class="nav-link" data-scroll-target="#sec-estimacion-parametros"><span class="header-section-number">3.6.1</span> Estimación de Parámetros</a></li>
  <li><a href="#sec-prediccion" id="toc-sec-prediccion" class="nav-link" data-scroll-target="#sec-prediccion"><span class="header-section-number">3.6.2</span> Predicción</a></li>
  <li><a href="#sec-rendimiento" id="toc-sec-rendimiento" class="nav-link" data-scroll-target="#sec-rendimiento"><span class="header-section-number">3.6.3</span> Rendimiento</a></li>
  </ul></li>
  <li><a href="#sec-cl-bayesiano-ingenuo" id="toc-sec-cl-bayesiano-ingenuo" class="nav-link" data-scroll-target="#sec-cl-bayesiano-ingenuo"><span class="header-section-number">3.7</span> Clasificador Bayesiano Ingenuo</a></li>
  <li><a href="#sec-ejemplo-breast-cancer-wisconsin" id="toc-sec-ejemplo-breast-cancer-wisconsin" class="nav-link" data-scroll-target="#sec-ejemplo-breast-cancer-wisconsin"><span class="header-section-number">3.8</span> Ejemplo: Breast Cancer Wisconsin</a>
  <ul class="collapse">
  <li><a href="#entrenamiento" id="toc-entrenamiento" class="nav-link" data-scroll-target="#entrenamiento"><span class="header-section-number">3.8.1</span> Entrenamiento</a></li>
  <li><a href="#predicción" id="toc-predicción" class="nav-link" data-scroll-target="#predicción"><span class="header-section-number">3.8.2</span> Predicción</a></li>
  <li><a href="#sec-gaussina-perf-breast_cancer" id="toc-sec-gaussina-perf-breast_cancer" class="nav-link" data-scroll-target="#sec-gaussina-perf-breast_cancer"><span class="header-section-number">3.8.3</span> Rendimiento</a></li>
  </ul></li>
  <li><a href="#diferencias-en-rendimiento" id="toc-diferencias-en-rendimiento" class="nav-link" data-scroll-target="#diferencias-en-rendimiento"><span class="header-section-number">3.9</span> Diferencias en Rendimiento</a></li>
  <li><a href="#sec-regresion-ols" id="toc-sec-regresion-ols" class="nav-link" data-scroll-target="#sec-regresion-ols"><span class="header-section-number">3.10</span> Regresión</a>
  <ul class="collapse">
  <li><a href="#sec-diabetes" id="toc-sec-diabetes" class="nav-link" data-scroll-target="#sec-diabetes"><span class="header-section-number">3.10.1</span> Ejemplo: Diabetes</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-metodos-parametricos" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Métodos Paramétricos</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Código</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Mostrar todo el código</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Ocultar todo el código</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">Ver el código fuente</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>El <strong>objetivo</strong> de la unidad es conocer las características de los modelos paramétricos y aplicar máxima verosimilitud para estimar los parámetros del modelo paramétrico en problemas de regresión y clasificación.</p>
<section id="paquetes-usados" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="paquetes-usados">Paquetes usados</h2>
<div id="ed28b76d" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.discriminant_analysis <span class="im">import</span> QuadraticDiscriminantAnalysis</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.naive_bayes <span class="im">import</span> GaussianNB</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_breast_cancer,<span class="op">\</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                             load_diabetes</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm, multivariate_normal</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> logsumexp</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pylab <span class="im">as</span> plt</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<hr>
<div class="quarto-video"><iframe data-external="1" src="https://www.youtube.com/embed/Tlwecs3dUPw" width="560" height="315" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<hr>
</section>
<section id="sec-intro-03" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-intro-03"><span class="header-section-number">3.1</span> Introducción</h2>
<p>Existen diferentes tipos de algoritmos que se puede utilizar para resolver problemas de aprendizaje supervisado y no supervisado. En particular, esta unidad se enfoca en presentar las técnicas que se pueden caracterizar como métodos paramétricos.</p>
<p>Los métodos paramétricos se identifican por asumir que los datos provienen de una distribución de la cual se desconocen los parámetros y el procedimiento es encontrar los parámetros de la distribución que mejor modelen los datos. Una vez obtenidos los parámetros se cuenta con todos los elementos para utilizar el modelo y predecir la característica para la cual fue entrenada.</p>
</section>
<section id="sec-metodologia-met-parametricos" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-metodologia-met-parametricos"><span class="header-section-number">3.2</span> Metodología</h2>
<p>Hasta el momento se han presentado ejemplos de los pasos 4 y 5 de la metodología general (ver <a href="01Introduccion.html#sec-metodologia-general" class="quarto-xref"><span>Sección 1.2</span></a>); esto fue en la <a href="02Teoria_Decision.html#sec-prediccion-normal" class="quarto-xref"><span>Sección 2.3.2</span></a> y en la <a href="02Teoria_Decision.html#sec-error-clasificacion" class="quarto-xref"><span>Sección 2.4</span></a>. Esta sección complementa los ejemplos anteriores al utilizar todos pasos de la metodología general de aprendizaje supervisado (ver <a href="01Introduccion.html#sec-metodologia-general" class="quarto-xref"><span>Sección 1.2</span></a>). En particular se enfoca al paso 3 que corresponde al diseño del algoritmo <span class="math inline">\(f\)</span> que modela el fenómeno de interés utilizando los datos <span class="math inline">\(\mathcal T \subset \mathcal D.\)</span></p>
<p>El algoritmo <span class="math inline">\(f\)</span> corresponde a asumir que los datos <span class="math inline">\(\mathcal D\)</span> provienen de una distribución <span class="math inline">\(F\)</span> la cual tiene una serie de parámetros <span class="math inline">\(\theta\)</span> que son identificados con <span class="math inline">\(\mathcal T.\)</span></p>
</section>
<section id="sec-estimacion-parametros-gnal" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-estimacion-parametros-gnal"><span class="header-section-number">3.3</span> Estimación de Parámetros</h2>
<p>Se inicia la descripción de métodos paramétricos presentando el procedimiento general para estimar los parámetros de una distribución. Se cuenta con un conjunto <span class="math inline">\(\mathcal D\)</span> donde los elementos <span class="math inline">\(x \in \mathcal D\)</span> son <span class="math inline">\(x \in \mathbb R^d\)</span>. Los elementos <span class="math inline">\(x \in \mathcal D\)</span> tienen un distribución <span class="math inline">\(F\)</span>, i.e., <span class="math inline">\(x \sim F\)</span>, son independientes y <span class="math inline">\(F\)</span> está definida por la función de densidad de probabilidad <span class="math inline">\(f_{\theta}\)</span>, que a su vez está definida por <span class="math inline">\(\theta\)</span> parámetros. Utilizando <span class="math inline">\(\mathcal D\)</span> el objetivo es identificar los parámetros <span class="math inline">\(\theta\)</span> que hacen observar a <span class="math inline">\(\mathcal D\)</span> lo más probable.</p>
<section id="sec-verosimilitud" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="sec-verosimilitud"><span class="header-section-number">3.3.1</span> Verosimilitud</h3>
<p>Una solución para maximizar el observar <span class="math inline">\(\mathcal D\)</span> es maximizando la verosimilitud. La verosimilitud es la función distribución conjunta de los elementos en <span class="math inline">\(\mathcal D\)</span>, i.e., <span class="math inline">\(f_\theta(x_1, x_2, \ldots, x_N).\)</span> Considerando que la muestras son independientes entonces <span class="math inline">\(f_\theta(x_1, x_2, \ldots, x_N) = \prod_{x \in \mathcal D} f_\theta (x).\)</span> La función de verosimilitud considera la ecuación anterior como una función de los parámetros <span class="math inline">\(\theta,\)</span> es decir,</p>
<p><span class="math display">\[
\mathcal L(\theta) = \prod_{x \in \mathcal D} f_\theta (x),
\]</span></p>
<p>siendo el logaritmo de la verosimilitud</p>
<p><span class="math display">\[
\ell(\theta) = \log \mathcal L(\theta) = \sum_{x \in \mathcal D} \log f_\theta (x).
\]</span></p>
</section>
<section id="sec-distribucción-de-bernoulli" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="sec-distribucción-de-bernoulli"><span class="header-section-number">3.3.2</span> Distribución de Bernoulli</h3>
<p>La verosimilitud se ejemplifica con la identificación del parámetro <span class="math inline">\(p\)</span> de una distribución Bernoulli. Una distribución Bernoulli modela dos estados, por un lado se tiene la clase negativa identificada por <span class="math inline">\(0\)</span>; identificando la clase positiva como <span class="math inline">\(1\)</span>. Entonces, la probabilidad de observar <span class="math inline">\(1\)</span> es <span class="math inline">\(\mathbb P(X=1) = p\)</span> y <span class="math inline">\(\mathbb P(X=0) = 1 - p\)</span>. Estas ecuaciones se pueden combinar para definir <span class="math inline">\(f_\theta(x) = p^x (1 - p)^{1-x}.\)</span></p>
<p>Utilizando el logaritmo de la verosimilitud se tiene:</p>
<p><span class="math display">\[
\ell(p) = \sum_{i=1}^N \log p^{x_i} (1 - p)^{1-x_i} = \sum_{i=1}^N x_i \log p + (1-x_i) \log (1 - p).
\]</span></p>
<p>Recordando que el máximo de <span class="math inline">\(\ell(\mathcal p)\)</span> se obtiene cuando <span class="math inline">\(\frac{d}{dp} \ell(\mathcal p) = 0\)</span>, entonces estimar <span class="math inline">\(p\)</span> corresponde a resolver lo siguiente:</p>
<p><span class="math display">\[
\begin{split}
\frac{d}{dp} \ell(\mathcal p) &amp;= 0 \\
\frac{d}{dp} [ \sum_{i=1}^N x_i \log p + (1-x_i) \log (1 - p)] &amp;= 0 \\
\frac{d}{d p} [ \sum_{i=1}^N x_i \log p + \log (1 - p) (N - \sum_{i=1}^N x_i) ] &amp;= 0\\
\sum_{i=1}^N x_i \frac{d}{d p} \log \mathcal p + (N - \sum_{i=1}^N x_i) \frac{d}{d p} \log (1 - \mathcal p) &amp;= 0\\
\sum_{i=1}^N x_i \frac{1}{p} + (N - \sum_{i=1}^N x_i) \frac{-1}{(1 - p)} &amp;= 0\\
\end{split}
\]</span></p>
<p>Realizando algunas operaciones algebraicas se obtiene:</p>
<p><span class="math display">\[
\hat p = \frac{1}{N}\sum_{i=1}^N x_i.
\]</span></p>
</section>
<section id="sec-estimacion-distribucion-gausiana" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="sec-estimacion-distribucion-gausiana"><span class="header-section-number">3.3.3</span> Ejemplo: Distribución Gausiana</h3>
<p>Esta sección sigue un camino práctico, presentando el código para estimar los parámetros de una distribución Gausiana donde se conocen todos los parámetros. La distribución se usa para generar 1000 muestras y después de esta población se estiman los parámetros; de estas manera se tienen todos los elementos para comparar los parámetros reales <span class="math inline">\(\theta\)</span> de los parámetros estimados <span class="math inline">\(\hat \theta.\)</span></p>
<p>La distribución que se usará se utilizó para generar un problema sintético (ver <a href="02Teoria_Decision.html#sec-tres-normales" class="quarto-xref"><span>Sección 2.3.1</span></a>) de tres clases. Los parámetros de la distribución son: <span class="math inline">\(\mathbf \mu = [5, 5]^\intercal\)</span> y <span class="math inline">\(\Sigma = \begin{pmatrix} 4 &amp; 0 \\ 0 &amp; 2 \\ \end{pmatrix}.\)</span> La siguiente instrucción se puede utilizar para generar 1000 muestras de esa distribución.</p>
<div id="30e40263" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="dv">5</span>, <span class="dv">5</span>], </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                        cov<span class="op">=</span>[[<span class="dv">4</span>, <span class="dv">0</span>], </span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>                             [<span class="dv">0</span>, <span class="dv">2</span>]]).rvs(size<span class="op">=</span><span class="dv">1000</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La media estimada de los datos en <code>D</code> se calcula usando la función <code>np.mean</code> de la siguiente manera</p>
<div id="1e559f84" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.mean(D, axis<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ae019f8f" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="5">
<p>donde el eje de operación es el primero que corresponde al índice <span class="math inline">\(0.\)</span> La media estimada es: <span class="math inline">\(\hat \mu = [5.0411, 5.0338]^\intercal\)</span> con un <a href="ver @sec-error-estandar-media">error estándar</a> (<code>se</code>) de <span class="math inline">\([0.0644, 0.0467]^\intercal\)</span> que se calcula con el siguiente código.</p>
</div>
</div>
<div id="31ea596c" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(D, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> np.sqrt(<span class="dv">1000</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Hasta el momento se ha estimado <span class="math inline">\(\mu\)</span>, falta por estimar <span class="math inline">\(\Sigma\)</span>, que se puede realizar con la siguiente instrucción</p>
<div id="aca86415" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>cov <span class="op">=</span> np.cov(D, rowvar<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="387bf1e6" class="cell" data-execution_count="8">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="8">
<p>donde el parámetro <code>rowvar</code> indica la forma en que están proporcionados los datos. La estimación da los siguientes valores <span class="math inline">\(\hat \Sigma = \begin{pmatrix} 4.1524&amp;0.0465 \\ 0.0465&amp;2.1854 \\ \end{pmatrix};\)</span> se puede observar que son similares al parámetro con que se simularon los datos.</p>
</div>
</div>
<p>Siguiendo con la inercia de presentar el error estándar de cada estimación, en las siguientes instrucciones se presenta el error estándar de <span class="math inline">\(\hat \Sigma\)</span>, el cual se calcula utilizando la técnica de bootstrap (ver <a href="14Estadistica.html#sec-bootstrap" class="quarto-xref"><span>Sección A.2</span></a>) implementada en el siguiente código.</p>
<div id="04f96548" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.random.randint(D.shape[<span class="dv">0</span>],</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>                      size<span class="op">=</span>(<span class="dv">500</span>, D.shape[<span class="dv">0</span>]))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [np.cov(D[s], rowvar<span class="op">=</span><span class="va">False</span>) <span class="cf">for</span> s <span class="kw">in</span> S]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(B, axis<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="dafa09f2" class="cell" data-execution_count="10">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="10">
<p>Se puede observar que la función <code>np.cov</code> se ejecuta utilizando la muestra indicada en la variable <code>s</code>. El error estándar (<code>se</code>) de <span class="math inline">\(\hat \Sigma\)</span> corresponde a <span class="math inline">\(\begin{pmatrix} 0.1765&amp;0.0910 \\ 0.0910&amp;0.0955 \\ \end{pmatrix}.\)</span> Se observa que los elementos fuera de la diagonal tienen un error estándar tal que el cero se encuentra en el intervalo <span class="math inline">\(\hat \Sigma \pm se;\)</span> lo cual indica que el cero es un valor factible. Lo anterior se puede verificar tomando en cuenta que se conoce <span class="math inline">\(\Sigma\)</span> y que el parámetro real es <span class="math inline">\(0\)</span> para aquellos elementos fuera de la diagonal.</p>
</div>
</div>
</section>
</section>
<section id="metodología-de-clasificación" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="metodología-de-clasificación"><span class="header-section-number">3.4</span> Metodología de Clasificación</h2>
<p>Habiendo descrito el proceso para estimar los parámetros de una distribución, por un lado se presentó de manera teórica con la distribución Bernoulli (ver <a href="#sec-distribucción-de-bernoulli" class="quarto-xref"><span>Sección 3.3.2</span></a>) y de manera práctica con una distribución Gausiana (ver <a href="#sec-estimacion-distribucion-gausiana" class="quarto-xref"><span>Sección 3.3.3</span></a>), se está en la posición de usar todos estos elementos para presentar el proceso completo de clasificación. La metodología general de aprendizaje supervisado (ver <a href="01Introduccion.html#sec-metodologia-general" class="quarto-xref"><span>Sección 1.2</span></a>) está definida por cinco pasos, estos pasos se especializan para el problema de clasificación y regresión, utilizando modelos paramétricos, de la siguiente manera.</p>
<ol type="1">
<li>Todo empieza con un conjunto de datos <span class="math inline">\(\mathcal D\)</span> que tiene la información del fenómeno de interés.</li>
<li>Se selecciona el conjunto <span class="math inline">\(\mathcal T \subset \mathcal D,\)</span> el procedimiento se describe en la <a href="#sec-conjunto-entre-prueba" class="quarto-xref"><span>Sección 3.5</span></a>.</li>
<li>Se diseña un algoritmo, <span class="math inline">\(f\)</span>, el cual se basa en un modelo (ver <a href="#sec-model-clasificacion" class="quarto-xref"><span>Sección 3.6</span></a>) y la estimación de sus parámetros (ver <a href="#sec-estimacion-parametros" class="quarto-xref"><span>Sección 3.6.1</span></a>) utilizando <span class="math inline">\(\mathcal T.\)</span></li>
<li>En la <a href="#sec-prediccion" class="quarto-xref"><span>Sección 3.6.2</span></a> se describe el uso de <span class="math inline">\(f\)</span> para predecir.</li>
<li>La <a href="#sec-rendimiento" class="quarto-xref"><span>Sección 3.6.3</span></a> muestra el procedimiento para medir el rendimiento utilizando un conjunto de prueba (ver <a href="#sec-conjunto-entre-prueba" class="quarto-xref"><span>Sección 3.5</span></a>).</li>
</ol>
<p>La metodología de clasificación se ilustra utilizando el problema sintético (ver <a href="02Teoria_Decision.html#sec-tres-normales" class="quarto-xref"><span>Sección 2.3.1</span></a>) de tres clases que se presentó en el <a href="02Teoria_Decision.html" class="quarto-xref"><span>Capítulo 2</span></a>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Problema sintético
</div>
</div>
<div class="callout-body-container callout-body">
<div id="8c3a456b" class="cell" data-execution_count="11">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="dv">5</span>, <span class="dv">5</span>],</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                         cov<span class="op">=</span>[[<span class="dv">4</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">2</span>]],</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                         seed<span class="op">=</span>seed)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>p2 <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="fl">1.5</span>, <span class="op">-</span><span class="fl">1.5</span>],</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                         cov<span class="op">=</span>[[<span class="dv">2</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">3</span>]],</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                         seed<span class="op">=</span>seed)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>p3 <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="fl">12.5</span>, <span class="op">-</span><span class="fl">3.5</span>], </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>                         cov<span class="op">=</span>[[<span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">3</span>, <span class="dv">7</span>]],</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                         seed<span class="op">=</span>seed)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>X_1 <span class="op">=</span> p1.rvs(size<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>X_2 <span class="op">=</span> p2.rvs(size<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>X_3 <span class="op">=</span> p3.rvs(size<span class="op">=</span><span class="dv">1000</span>)                         </span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
<p>Específicamente, las entradas que definían a cada clase están en la variables <code>X_1</code>, <code>X_2</code> y <code>X_3</code>. Entonces las clases se pueden colocar en la variable <code>y</code> tal como se indica a continuación.</p>
<div id="90fac46a" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.concatenate((X_1, X_2, X_3))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([<span class="dv">1</span>] <span class="op">*</span> <span class="dv">1000</span> <span class="op">+</span> [<span class="dv">2</span>] <span class="op">*</span> <span class="dv">1000</span> <span class="op">+</span> [<span class="dv">3</span>] <span class="op">*</span> <span class="dv">1000</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Las variables <code>X</code> y <code>y</code> contiene la información del conjunto <span class="math inline">\(\mathcal D = (\mathcal X, \mathcal Y)\)</span> donde cada renglón de <code>X</code> es una realización de la variable aleatoria <span class="math inline">\(\mathcal X\)</span> y equivalentemente cada elemento en <code>y</code> es una realización de <span class="math inline">\(\mathcal Y.\)</span></p>
</section>
<section id="sec-conjunto-entre-prueba" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="sec-conjunto-entre-prueba"><span class="header-section-number">3.5</span> Conjunto de Entrenamiento y Prueba</h2>
<p>En la <a href="#sec-estimacion-distribucion-gausiana" class="quarto-xref"><span>Sección 3.3.3</span></a> se había utilizado a <span class="math inline">\(\mathcal D\)</span> en el procedimiento de maximizar la verosimilitud, esto porque el objetivo en ese procedimiento era estimar los parámetros de la distribución. Pero el objetivo en aprendizaje supervisado es diseñar un algoritmo (función en este caso) que modele la relación entre <span class="math inline">\(\mathcal X\)</span> y <span class="math inline">\(\mathcal Y\)</span>. Para conocer esto es necesario medir el rendimiento del algoritmo en instancias que no han sido vistas en el entrenamiento.</p>
<p>En consecuencia, se requieren contar con datos para medir el rendimiento, a este conjunto de datos se le conoce como el conjunto de prueba, <span class="math inline">\(\mathcal G\)</span>. <span class="math inline">\(\mathcal G\)</span> se crea a partir de <span class="math inline">\(\mathcal D\)</span> de tal manera que <span class="math inline">\(\mathcal G \cap \mathcal T = \emptyset\)</span> y <span class="math inline">\(\mathcal D =  \mathcal G \cup \mathcal T.\)</span> La siguiente instrucción se puede utilizar para dividir la generación de estos conjuntos a partir de <span class="math inline">\(\mathcal D.\)</span></p>
<div id="781854b4" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>T, G, y_t, y_g <span class="op">=</span> train_test_split(X, y,</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>                                  test_size<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                                  random_state<span class="op">=</span>seed)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El parámetro <code>test_size</code> indica la proporción del tamaño de conjunto <span class="math inline">\(\mathcal G\)</span> en relación con el conjunto <span class="math inline">\(\mathcal D.\)</span></p>
</section>
<section id="sec-model-clasificacion" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="sec-model-clasificacion"><span class="header-section-number">3.6</span> Clasificador</h2>
<p>El inicio de métodos paramétricos es el Teorema de Bayes (<a href="02Teoria_Decision.html#eq-teorema-bayes" class="quarto-xref">Ecuación&nbsp;<span>2.1</span></a>) <span class="math inline">\(\mathbb P(\mathcal Y \mid \mathcal X) = \frac{ \mathbb P(\mathcal X \mid \mathcal Y) \mathbb P(\mathcal Y)}{\mathbb P(\mathcal X)}\)</span> donde se usa la verosimilitud <span class="math inline">\(\mathbb P(\mathcal X \mid \mathcal Y)\)</span> y el prior <span class="math inline">\(\mathbb P(\mathcal Y)\)</span> para definir la probabilidad a posteriori <span class="math inline">\(\mathbb P(\mathcal Y \mid \mathcal X)\)</span>. En métodos paramétricos se asume que se puede modelar la verosimilitud con una distribución particular, que por lo generar es una distribución Gausiana multivariada. Es decir, la variable aleatoria <span class="math inline">\(\mathcal X\)</span> dado <span class="math inline">\(\mathcal Y\)</span> (i.e., <span class="math inline">\(\mathcal X_{\mid \mathcal Y}\)</span>) es <span class="math inline">\(\mathcal X_{\mid \mathcal Y} \sim \mathcal N(\mu_{\mathcal Y}, \Sigma_{\mathcal Y}),\)</span> donde se observa que los parámetros de la distribución Gausiana dependen de la variable aleatoria <span class="math inline">\(\mathcal Y\)</span> y estos pueden ser identificados cuando <span class="math inline">\(\mathcal Y\)</span> tiene un valor específico.</p>
<section id="sec-estimacion-parametros" class="level3" data-number="3.6.1">
<h3 data-number="3.6.1" class="anchored" data-anchor-id="sec-estimacion-parametros"><span class="header-section-number">3.6.1</span> Estimación de Parámetros</h3>
<p>Dado que por definición del problema (ver <a href="02Teoria_Decision.html#sec-tres-normales" class="quarto-xref"><span>Sección 2.3.1</span></a>) se conoce que la verosimilitud para cada clase proviene de una Gausiana, i.e., <span class="math inline">\(\mathcal X_{\mid \mathcal Y} \sim \mathcal N(\mu_{\mathcal Y}, \Sigma_{\mathcal Y}),\)</span> en esta sección se estimarán los parámetros utilizando este conocimiento.</p>
<p>El primer paso en la estimación de parámetros es calcular el prior <span class="math inline">\(\mathbb P(\mathcal Y)\)</span>, el cual corresponde a clasificar el evento sin observar el valor de <span class="math inline">\(\mathcal X.\)</span> Esto se puede modelar mediante una distribución Categórica con parámetros <span class="math inline">\(p_i\)</span> donde <span class="math inline">\(\sum_i^K p_i = 1\)</span>. Estos parámetros se pueden estimar utilizando la función <code>np.unique</code> de la siguiente manera</p>
<div id="fcf9908e" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>labels, counts <span class="op">=</span> np.unique(y_t, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>prior <span class="op">=</span> counts <span class="op">/</span> counts.<span class="bu">sum</span>()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La variable <code>prior</code> contiene en el primer elemento <span class="math inline">\(\mathbb P(\mathcal Y=1) = 0.3179,\)</span> en el segundo <span class="math inline">\(\mathbb P(\mathcal Y=2) = 0.3387\)</span> y en el tercero <span class="math inline">\(\mathbb P(\mathcal Y=3) = 0.3433\)</span> que es aproximadamente <span class="math inline">\(\frac{1}{3}\)</span> el cual es el valor real del prior.</p>
<p>Siguiendo los pasos en estimación de parámetros de una Gausiana (<a href="#sec-estimacion-distribucion-gausiana" class="quarto-xref"><span>Sección 3.3.3</span></a>) se pueden estimar los parámetros para cada Gausiana dada la clase. Es decir, se tiene que estimar los parámetros <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\Sigma\)</span> para la clase <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span> y <span class="math inline">\(3.\)</span> El algoritmo de clasificación que estima <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\Sigma\)</span> para cada clase se le conoce como <strong>Analizador Discriminante Cuadrático</strong> implementando en la clase <code>QuadraticDiscriminantAnalysis</code>.</p>
<p>Una implementación directa para la estimación de los parámetros se puede realizar iterando por las etiquetas contenidas en la variable <code>labels</code> y seleccionando los datos en <code>T</code> que corresponden a la clase analizada, ver el uso de la variable <code>mask</code> en el slice de la línea 4 y 5. Después se inicializa una instancia de la clase <code>multivariate_normal</code> para ser utilizada en el cómputo de la función de densidad de probabilidad. El paso final es guardar las instancias de las distribuciones en la lista <code>likelihood</code>.</p>
<div id="2f1d8bc9" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>likelihood <span class="op">=</span> []</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> labels:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y_t <span class="op">==</span> k</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> np.mean(T[mask], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    cov <span class="op">=</span> np.cov(T[mask], rowvar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    likelihood_k <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>mu, cov<span class="op">=</span>cov)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    likelihood.append(likelihood_k)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1a1b2cce" class="cell" data-execution_count="16">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="16">
<p>Los valores estimados para la media, en cada clase son: <span class="math inline">\(\hat \mu_1 = [5.0267, 4.9626]^\intercal,\)</span> <span class="math inline">\(\hat \mu_2 = [1.5687, -1.4642]^\intercal\)</span> y <span class="math inline">\(\hat \mu_3 = [12.5188, -3.4715]^\intercal\)</span>. Para las matrices de covarianza, los valores estimados corresponden a <span class="math inline">\(\hat \Sigma_1 = \begin{pmatrix} 3.8108 &amp; -0.0363\\-0.0363 &amp; 1.9319 \\ \end{pmatrix},\)</span> <span class="math inline">\(\hat \Sigma_2 = \begin{pmatrix} 1.8221 &amp; 0.8862\\0.8862 &amp; 2.8153 \\ \end{pmatrix}\)</span> y <span class="math inline">\(\hat \Sigma_3 = \begin{pmatrix} 1.9043 &amp; 2.8677\\2.8677 &amp; 6.7392 \\ \end{pmatrix}.\)</span></p>
</div>
</div>
<p>Estas estimaciones se pueden comparar con los parámetros reales (<a href="02Teoria_Decision.html#sec-tres-normales" class="quarto-xref"><span>Sección 2.3.1</span></a>). También se puede calcular su error estándar para identificar si el parámetro real, <span class="math inline">\(\theta\)</span>, se encuentra en el intervalo definido por <span class="math inline">\(\hat \theta - 2\hat{se} \leq \hat \theta \leq \hat \theta + 2 \hat{se}\)</span> que corresponde aproximadamente al 95% de confianza asumiendo que la distribución de la estimación del parámetro es Gausiana.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nota
</div>
</div>
<div class="callout-body-container callout-body">
<p>El código anterior tiene el fin de explicar el procedimiento para estimar los parámetros, la clase <code>QuadraticDiscriminantAnalysis</code> implementa diferentes métodos de estimación y se puede utilizar con el siguiente código.</p>
<div id="61c6ea50" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>qda <span class="op">=</span> QuadraticDiscriminantAnalysis(store_covariance<span class="op">=</span><span class="va">True</span>).fit(T, y_t)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los parámetros <span class="math inline">\(\mu\)</span> se encuentran en el siguiente atributo. Se puede observar que los valores estimados por el método explicado y el implementado en QDA es el mismo.</p>
<div id="640b3073" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>qda.means_</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>array([[ 5.0267,  4.9626],
       [ 1.5687, -1.4642],
       [12.5188, -3.4715]])</code></pre>
</div>
</div>
<p>Los parámetros estimados para <span class="math inline">\(\Sigma_1\)</span> se pueden obtener en el siguiente atributo</p>
<div id="4098b522" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>qda.covariance_[<span class="dv">0</span>]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>array([[ 3.8108, -0.0363],
       [-0.0363,  1.9319]])</code></pre>
</div>
</div>
<p>Se observa que los valores son equivalentes entre los dos procedimientos, es importante mencionar que estos parámetros solamente están disponibles si la clase se inicializa con el parámetro <code>store_covariance</code> en verdadero.</p>
</div>
</div>
</section>
<section id="sec-prediccion" class="level3" data-number="3.6.2">
<h3 data-number="3.6.2" class="anchored" data-anchor-id="sec-prediccion"><span class="header-section-number">3.6.2</span> Predicción</h3>
<p>Una vez que se tiene la función que modela los datos, se está en condiciones de utilizarla para predecir (ver <a href="02Teoria_Decision.html#sec-prediccion-normal" class="quarto-xref"><span>Sección 2.3.2</span></a>) nuevos datos.</p>
<p>En esta ocasión se organiza el procedimiento de predicción en diferentes funciones, la primera función recibe los datos a predecir <code>X</code> y los componentes del modelo, que son la verosimilitud (<code>likelihood</code>) y el <code>prior</code>. La función calcula <span class="math inline">\(\mathbb P(\mathcal Y=y \mid \mathcal X=x)\)</span> que es la probabilidad de cada clase dada la entrada <span class="math inline">\(x\)</span>. Se puede observar en la primera línea que se usa la función de densidad de probabilidad (<code>pdf</code>) para cada clase y esta se multiplica por el <code>prior</code> y en la tercera línea se calcula la evidencia. Finalmente, se regresa el a posteriori.</p>
<div id="bebcce5b" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict_prob(X, likelihood, prior):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    likelihood <span class="op">=</span> [m.pdf(X) <span class="cf">for</span> m <span class="kw">in</span> likelihood]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    posterior <span class="op">=</span> np.vstack(likelihood).T <span class="op">*</span> prior</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    evidence <span class="op">=</span> posterior.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> posterior <span class="op">/</span> np.atleast_2d(evidence).T</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La función <code>predict_proba</code> se utiliza como base para predecir la clase, para la cual se requiere el mapa entre índices y clases que se encuentra en la variable <code>labels</code>. Se observa que se llama a la función <code>predict_proba</code> y después se calcula el argumento que tiene la máxima probabilidad regresando la etiqueta asociada.</p>
<div id="bae776e4" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict(X, likelihood, prior, labels):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> predict_prob(X, likelihood, prior)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> labels[np.argmax(_, axis<span class="op">=</span><span class="dv">1</span>)]</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nota
</div>
</div>
<div class="callout-body-container callout-body">
<p>La predicción en la clase <code>QuadraticDiscriminantAnalysis</code> se puede realizar invocando al siguiente método tal y como se muestra en la siguiente linea.</p>
<div id="10c75a54" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>qda_hy <span class="op">=</span> qda.predict(G)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La probabilidad se puede obtener utilizando el método <code>predict_proba.</code></p>
<div id="0acc0404" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>qda_prob <span class="op">=</span> qda.predict_proba(G)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</section>
<section id="sec-rendimiento" class="level3" data-number="3.6.3">
<h3 data-number="3.6.3" class="anchored" data-anchor-id="sec-rendimiento"><span class="header-section-number">3.6.3</span> Rendimiento</h3>
<p>El rendimiento del algoritmo se mide en el conjunto de prueba <code>G</code>, utilizando como medida el error de clasificación (<a href="02Teoria_Decision.html#sec-error-clasificacion" class="quarto-xref"><span>Sección 2.4</span></a>). El primer paso es predecir las clases de los elementos en <code>G</code>, utilizando la función <code>predict</code> que fue diseñada anteriormente. Después se mide el error, con la instrucción de la segunda línea.</p>
<div id="5dbb6669" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>hy <span class="op">=</span> predict(G, likelihood, prior, labels)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> (y_g <span class="op">!=</span> hy).mean()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El error que tiene el algoritmo en el conjunto de prueba es <span class="math inline">\(0.0117\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nota
</div>
</div>
<div class="callout-body-container callout-body">
<p>El error utilizado <code>qda_hy</code> corresponde a <span class="math inline">\(0.0117.\)</span></p>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Actividad
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Utilizando la probabilidad en el conjunto de prueba, que se tiene en la variable <code>qda_prob</code>, calcular la variación del número de elementos que son asociados a la acción nula cuando se varía el nivel de riesgo (ver <a href="02Teoria_Decision.html#sec-seleccion-accion-nula" class="quarto-xref"><span>Sección 2.6</span></a>), incluir en la figura o en una figura adicional, la dinámica del error en el conjunto de prueba para los elementos válidos. La <a href="#fig-actividad-riesgo-nulo-error" class="quarto-xref">Figura&nbsp;<span>3.1</span></a> muestra el resultado de este proceso. Se observa como van disminuyendo el número de elementos asociados a la acción nula cuando el riesgo se incrementa y al mismo tiempo como el error aumenta.</p>
<div id="cell-fig-actividad-riesgo-nulo-error" class="cell" data-execution_count="25">
<div class="cell-output cell-output-display">
<div id="fig-actividad-riesgo-nulo-error" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-actividad-riesgo-nulo-error-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="03Parametricos_files/figure-html/fig-actividad-riesgo-nulo-error-output-1.png" width="658" height="429" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-actividad-riesgo-nulo-error-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.1: Variación del número de elementos que seleccionan la acción nula y el error en el conjunto de prueba respecto al riesgo
</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Para calcular el error estándar se utiliza el siguiente código</p>
<div id="c60d50f7" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>se_formula <span class="op">=</span> np.sqrt(error <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> error) <span class="op">/</span> y_g.shape[<span class="dv">0</span>])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>dando un valor de <span class="math inline">\(0.0044.\)</span></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-6-contents" aria-controls="callout-6" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Actividad
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-6" class="callout-6-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Generar la distribución del error utilizando el método de Bootstrap (ver <a href="14Estadistica.html#sec-bootstrap" class="quarto-xref"><span>Sección A.2</span></a>), tal y como se muestra en la <a href="#fig-actividad-distribucion" class="quarto-xref">Figura&nbsp;<span>3.2</span></a>.</p>
<div id="cell-fig-actividad-distribucion" class="cell" data-execution_count="27">
<div class="cell-output cell-output-display">
<div id="fig-actividad-distribucion" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-actividad-distribucion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="03Parametricos_files/figure-html/fig-actividad-distribucion-output-1.png" width="471" height="470" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-actividad-distribucion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.2: Distribución del error
</figcaption>
</figure>
</div>
</div>
</div>
<p>El error estándar calculado con los datos mostrados en la figura anterior es <span class="math inline">\(0.0045\)</span></p>
</div>
</div>
</div>
</section>
</section>
<section id="sec-cl-bayesiano-ingenuo" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="sec-cl-bayesiano-ingenuo"><span class="header-section-number">3.7</span> Clasificador Bayesiano Ingenuo</h2>
<p>Uno de los clasificadores mas utilizados, sencillo de implementar y competitivo, es el clasificador Bayesiano Ingenuo. En la <a href="#sec-model-clasificacion" class="quarto-xref"><span>Sección 3.6</span></a> se asumió que la variable aleatoria <span class="math inline">\(\mathcal X = (\mathcal X_1, \mathcal X_2, \ldots, \mathcal X_d)\)</span> dado <span class="math inline">\(\mathcal Y\)</span> (<span class="math inline">\(\mathcal X_{\mid \mathcal Y}\)</span>) es <span class="math inline">\(\mathcal X_{\mid \mathcal Y} \sim \mathcal N(\mu_{\mathcal Y}, \Sigma_{\mathcal Y}),\)</span> donde <span class="math inline">\(\mu_{\mathcal Y} \in \mathbb R^d\)</span>, <span class="math inline">\(\Sigma_{\mathcal Y} \in \mathbb R^{d \times d}\)</span> y <span class="math inline">\(f(\mathcal X_1, \mathcal X_2, \ldots, \mathcal X_d)\)</span> es la función de densidad de probabilidad conjunta.</p>
<p>En el clasificador Bayesiano Ingenuo se asume que las variables <span class="math inline">\(\mathcal X_i\)</span> y <span class="math inline">\(\mathcal X_j\)</span> para <span class="math inline">\(i \neq j\)</span> son independientes, esto trae como consecuencia que <span class="math inline">\(f(\mathcal X_1, \mathcal X_2, \ldots, \mathcal X_d) = \prod_i^d f(\mathcal X_i).\)</span> Esto quiere decir que cada variable está definida como una Gausina donde se tiene que identificar <span class="math inline">\(\mu\)</span> y <span class="math inline">\(\sigma^2.\)</span></p>
<p>La estimación de los parámetros de estas distribuciones se puede realizar utilizando un código similar siendo la única diferencia que en se calcula <span class="math inline">\(\sigma^2\)</span> de cada variable en lugar de la covarianza <span class="math inline">\(\Sigma\)</span>, esto se puede observar en la quinta línea donde se usa la función <code>np.var</code> en el primer eje. El resto del código es equivalente al usado en la <a href="#sec-estimacion-parametros" class="quarto-xref"><span>Sección 3.6.1</span></a>.</p>
<div id="d59d15e5" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>likelihood <span class="op">=</span> []</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> labels:</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y_t <span class="op">==</span> k</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> np.mean(T[mask], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> np.var(T[mask], axis<span class="op">=</span><span class="dv">0</span>, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    likelihood_k <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>mu, cov<span class="op">=</span>var)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    likelihood.append(likelihood_k)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="22750a4f" class="cell" data-execution_count="29">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="29">
<p>Los parámetros estimados en la versión ingenua son equivalentes con respecto a las medias, i.e., <span class="math inline">\(\hat \mu_1 = [5.0267, 4.9626]^\intercal\)</span>, <span class="math inline">\(\hat \mu_2 = [1.5687, -1.4642] ^\intercal\)</span> y <span class="math inline">\(\hat \mu_3 = [12.5188, -3.4715]^\intercal\)</span>. La diferencia se puede observar en las varianzas, que a continuación se muestran como matrices de covarianza para resaltar la diferencia, i.e., <span class="math inline">\(\hat \Sigma_1 = \begin{pmatrix} 3.8108 &amp; 0.0000\\0.0000 &amp; 1.9319 \\ \end{pmatrix}\)</span>, <span class="math inline">\(\hat \Sigma_2 = \begin{pmatrix} 1.8221 &amp; 0.0000\\0.0000 &amp; 2.8153 \\ \end{pmatrix}\)</span> y <span class="math inline">\(\hat \Sigma_3 = \begin{pmatrix} 1.9043 &amp; 0.0000\\0.0000 &amp; 6.7392 \\ \end{pmatrix}\)</span> se observa como los elementos fuera de la diagonal son ceros, lo cual indica la independencia entra las variables de entrada.</p>
</div>
</div>
<p>Finalmente, el código para predecir se utiliza el código descrito en la <a href="#sec-prediccion" class="quarto-xref"><span>Sección 3.6.2</span></a> dado que el modelo está dado en las variables <code>likelihood</code> y <code>prior</code>.</p>
<div id="bd876cb1" class="cell" data-execution_count="30">
<div class="cell-output cell-output-display cell-output-markdown" data-execution_count="30">
<p>El <code>error</code> del clasificador Bayesiano Ingenuo, en el conjunto de prueba, es de <span class="math inline">\(0.01\)</span> y su error estándar (<code>se_formula</code>) es <span class="math inline">\(0.0041.\)</span></p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Nota
</div>
</div>
<div class="callout-body-container callout-body">
<p>El código anterior tiene la finalidad de explicar la estimación de parámetros del Clasificador Bayesiano Ingenuo. Este procedimiento se encuentra en la clase <code>GaussianNB</code>, en ese paquete se pueden encontrar implementaciones con otras distribuciones.</p>
<p>El siguiente código muestra su uso.</p>
<div id="9366bac9" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>naive <span class="op">=</span> GaussianNB().fit(T, y_t)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los parámetros <span class="math inline">\(\mu\)</span> se encuentran se pueden consultar con la siguiente instrucción</p>
<div id="23bfd9b3" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>naive.theta_</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="32">
<pre><code>array([[ 5.0267,  4.9626],
       [ 1.5687, -1.4642],
       [12.5188, -3.4715]])</code></pre>
</div>
</div>
<p>y <span class="math inline">\(\sigma^2\)</span> en</p>
<div id="ad439c6e" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>naive.var_</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="33">
<pre><code>array([[3.8058, 1.9293],
       [1.8199, 2.8119],
       [1.902 , 6.731 ]])</code></pre>
</div>
</div>
</div>
</div>
</section>
<section id="sec-ejemplo-breast-cancer-wisconsin" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="sec-ejemplo-breast-cancer-wisconsin"><span class="header-section-number">3.8</span> Ejemplo: Breast Cancer Wisconsin</h2>
<p>Esta sección ilustra el uso del clasificador Bayesiano al generar dos modelos (Clasificador Bayesiano (mejor conocido como el algoritmo de Análisis Discriminante Cuadrático) y Bayesiano Ingenuo) del conjunto de datos de <em>Breast Cancer Wisconsin.</em> Estos datos se pueden obtener utilizando la función <code>load_breast_cancer</code> tal y como se muestra a continuación.</p>
<div id="87160b98" class="cell" data-execution_count="34">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> load_breast_cancer(return_X_y<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El primer paso es contar con los conjuntos de <a href="../AprendizajeComputacional/capitulos/03Parametricos/#conjunto-de-entrenamiento-y-prueba">entrenamiento y prueba</a> para poder realizar de manera completa la evaluación del proceso de clasificación. Esto se realiza ejecutando la siguiente instrucción.</p>
<div id="dbc52157" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>T, G, y_t, y_g <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>                                  random_state<span class="op">=</span>seed)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="entrenamiento" class="level3" data-number="3.8.1">
<h3 data-number="3.8.1" class="anchored" data-anchor-id="entrenamiento"><span class="header-section-number">3.8.1</span> Entrenamiento</h3>
<p>Los dos modelos que se utilizarán será el clasificador de Análisis Discriminante Cuadrático y Bayesiano Ingenuo, utilizando las clases <code>QuadraticDiscriminantAnalysis</code> y <code>GaussianNB</code>. Las siguientes dos instrucciones inicializan estos dos clasificadores.</p>
<div id="d5ab28c1" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>qda <span class="op">=</span> QuadraticDiscriminantAnalysis().fit(T, y_t)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>naive <span class="op">=</span> GaussianNB().fit(T, y_t)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="predicción" class="level3" data-number="3.8.2">
<h3 data-number="3.8.2" class="anchored" data-anchor-id="predicción"><span class="header-section-number">3.8.2</span> Predicción</h3>
<p>Habiendo definido los dos clasificadores, las predicciones del conjunto de prueba se realiza de la siguiente manera.</p>
<div id="b2975fa5" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>hy_qda <span class="op">=</span> qda.predict(G)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>hy_naive <span class="op">=</span> naive.predict(G)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="sec-gaussina-perf-breast_cancer" class="level3" data-number="3.8.3">
<h3 data-number="3.8.3" class="anchored" data-anchor-id="sec-gaussina-perf-breast_cancer"><span class="header-section-number">3.8.3</span> Rendimiento</h3>
<p>El rendimiento de ambos clasificadores se calcula de la siguiente manera</p>
<div id="1b8fd1da" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>error_qda <span class="op">=</span> (y_g <span class="op">!=</span> hy_qda).mean()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>error_naive <span class="op">=</span> (y_g <span class="op">!=</span> hy_naive).mean()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El clasificador Bayesiano Gausiano tiene un error de <span class="math inline">\(0.0439\)</span> y el error de Bayesiano Ingenuo es <span class="math inline">\(0.0702.\)</span> Se ha visto que el error es una variable aleatoria, entonces la pregunta es saber si esta diferencia en rendimiento es significativa o es una diferencia que proviene de la aleatoriedad de los datos.</p>
</section>
</section>
<section id="diferencias-en-rendimiento" class="level2" data-number="3.9">
<h2 data-number="3.9" class="anchored" data-anchor-id="diferencias-en-rendimiento"><span class="header-section-number">3.9</span> Diferencias en Rendimiento</h2>
<p>Una manera de ver si existe una diferencia en rendimiento es calcular la diferencia entre los dos errores de clasificación, esto es</p>
<div id="3dde08c4" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>naive <span class="op">=</span> (y_g <span class="op">!=</span> hy_naive).mean()</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>completo <span class="op">=</span> (y_g <span class="op">!=</span> hy_qda).mean()</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> naive <span class="op">&gt;</span> completo:</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> naive <span class="op">-</span> completo</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> completo <span class="op">-</span> naive</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>que tiene un valor de <span class="math inline">\(0.0263\)</span>. De la misma manera que se ha utilizado la técnica de bootstrap (<a href="14Estadistica.html#sec-bootstrap" class="quarto-xref"><span>Sección A.2</span></a>) para calcular el error estándar de la media, se puede usar para estimar el error estándar de la diferencia en rendimiento. El siguiente código muestra el procedimiento para estimar este error estándar.</p>
<div id="b4bf33e9" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.random.randint(y_g.shape[<span class="dv">0</span>],</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>                      size<span class="op">=</span>(<span class="dv">500</span>, y_g.shape[<span class="dv">0</span>]))</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> naive <span class="op">&gt;</span> completo:</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    diff_f <span class="op">=</span> <span class="kw">lambda</span> s: (y_g[s] <span class="op">!=</span> hy_naive[s]).mean() <span class="op">-\</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>                       (y_g[s] <span class="op">!=</span> hy_qda[s]).mean()</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    diff_f <span class="op">=</span> <span class="kw">lambda</span> s: (y_g[s] <span class="op">!=</span> hy_qda[s]).mean() <span class="op">-\</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>                       (y_g[s] <span class="op">!=</span> hy_naive[s]).mean()</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [diff_f(s) <span class="cf">for</span> s <span class="kw">in</span> S]</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(B, axis<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El error estándar de la diferencia de rendimiento es de <span class="math inline">\(0.0190\)</span>, una procedimiento simple para saber si la diferencia observada es significativa, es dividir la diferencia entre su error estándar dando un valor de <span class="math inline">\(1.3821\)</span>. En el caso que el valor absoluto fuera igual o superior a 2 se sabría que la diferencia es significativa con una confianza de al menos 95%, esto asumiendo que la diferencia se comporta como una distribución Gausiana.</p>
<p>El histograma de los datos que se tienen en la variable <code>B</code> se observa en la <a href="#fig-diff-cl-bayesianos" class="quarto-xref">Figura&nbsp;<span>3.3</span></a>. Se puede ver que la forma del histograma asemeja una distribución Gausiana y que el cero esta en el cuerpo de la Gausiana, tal y como lo confirmó el cociente que se calculado.</p>
<div id="cell-fig-diff-cl-bayesianos" class="cell" data-execution_count="41">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.displot(B, kde<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-diff-cl-bayesianos" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-diff-cl-bayesianos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="03Parametricos_files/figure-html/fig-diff-cl-bayesianos-output-1.png" width="471" height="470" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-diff-cl-bayesianos-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.3: Diferencia entre Clasificadores Bayesianos
</figcaption>
</figure>
</div>
</div>
</div>
<p>Se puede conocer la probabilidad de manera exacta calculando el área bajo la curva a la izquierda del cero, este sería el valor <span class="math inline">\(p\)</span>, si este es menor a 0.05 quiere decir que se tiene una confianza mayor del 95% de que los rendimientos son diferentes. Para este ejemplo, el área se calcula con el siguiente código</p>
<div id="65328ab8" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> norm(loc<span class="op">=</span>diff, scale<span class="op">=</span>se)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> dist.cdf(<span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>teniendo el valor de <span class="math inline">\(0.0835\)</span>, lo que significa que se tiene una confianza del <span class="math inline">\(91\)</span>% de que los dos algoritmos son diferentes considerando el error de clasificación como medida de rendimiento.</p>
</section>
<section id="sec-regresion-ols" class="level2" data-number="3.10">
<h2 data-number="3.10" class="anchored" data-anchor-id="sec-regresion-ols"><span class="header-section-number">3.10</span> Regresión</h2>
<p>Hasta este momento se han revisado métodos paramétricos en clasificación, ahora es el turno de abordar el problema de regresión. La diferencia entre clasificación y regresión como se describió en la <a href="01Introduccion.html#sec-aprendizaje-supervisado" class="quarto-xref"><span>Sección 1.4</span></a> es que en regresión <span class="math inline">\(\mathcal Y \in \mathbb R.\)</span></p>
<p>El procedimiento de regresión que se describe en esta sección es regresión de <strong>Mínimos Cuadrados Ordinaria</strong> (OLS -<em>Ordinary Least Squares</em>-), en el cual se asume que <span class="math inline">\(\mathcal Y \sim \mathcal N(\mathbf w \cdot \mathbf x + \epsilon, \sigma^2)\)</span>, de tal manera que <span class="math inline">\(y = \mathbb E[\mathcal N(\mathbf w \cdot \mathbf x + \epsilon, \sigma^2)].\)</span></p>
<p>Trabajando con <span class="math inline">\(y = \mathbb E[\mathcal N(\mathbf w \cdot \mathbf x + \epsilon, \sigma^2)],\)</span> se considera lo siguiente <span class="math inline">\(y = \mathbb E[\mathcal N(\mathbf w \cdot \mathbf x, 0) + \mathcal N(0, \sigma^2)]\)</span> que implica que el error <span class="math inline">\(\epsilon\)</span> es independiente de <span class="math inline">\(\mathbf x\)</span>, lo cual se transforma en <span class="math inline">\(y = \mathbf w \cdot \mathbf x + \mathbb E[\epsilon],\)</span> donde <span class="math inline">\(\mathbb E[\epsilon]=0.\)</span> Por lo tanto <span class="math inline">\(y = \mathbf w \cdot \mathbf x.\)</span></p>
<p>La función de densidad de probabilidad de una Gausiana corresponde a</p>
<p><span class="math display">\[
f(\alpha) = \frac{1}{\sigma \sqrt{2 \pi}} \exp{-\frac{1}{2} (\frac{\alpha -  \mu}{\sigma})^2},
\]</span></p>
<p>donde <span class="math inline">\(\alpha\)</span>, en el caso de regresión, corresponde a <span class="math inline">\(\mathbf w \cdot \mathbf x\)</span> (i.e., <span class="math inline">\(\alpha = \mathbf w \cdot \mathbf x\)</span>).</p>
<p>Utilizando el método de verosimilitud el cual corresponde a maximizar</p>
<p><span class="math display">\[
\begin{split}
\mathcal L(\mathbf w, \sigma) &amp;= \prod_{(\mathbf x, y) \in \mathcal D} f(\mathbf w \cdot \mathbf x) \\
&amp;= \prod_{(\mathbf x, y) \in \mathcal D} \frac{1}{\sigma \sqrt{2\pi}} \exp{(-\frac{1}{2} (\frac{\mathbf w \cdot \mathbf x -  y}{\sigma})^2)} \\
\ell(\mathbf w, \sigma) &amp;= \sum_{(\mathbf x, y) \in \mathcal D}\log \frac{1}{\sigma \sqrt{2\pi}}  -\frac{1}{2} (\frac{\mathbf w \cdot \mathbf x -  y}{\sigma})^2 \\
&amp;= - \frac{1}{2\sigma^2}  \sum_{(\mathbf x, y) \in \mathcal D} (\mathbf w \cdot \mathbf x -  y)^2 - N \log \frac{1}{\sigma \sqrt{2\pi}}.
\end{split}
\]</span></p>
<p>El valor de cada parámetro se obtiene al calcular la derivada parcial con respecto al parámetro de interés, entonces se resuelven <span class="math inline">\(d\)</span> derivadas parciales para cada uno de los coeficientes <span class="math inline">\(\mathbf w\)</span>. En este proceso se observar que el término <span class="math inline">\(N \log \frac{1}{\sigma \sqrt{2\pi}}\)</span> no depende de <span class="math inline">\(\mathbf w\)</span> entonces no afecta el máximo siendo una constante en el proceso de derivación y por lo tanto se desprecia. Lo mismo pasa para la constante <span class="math inline">\(\frac{1}{2\sigma^2}\)</span>. Una vez obtenidos los parámetros <span class="math inline">\(\mathcal w\)</span> se obtiene el valor <span class="math inline">\(\sigma.\)</span></p>
<p>Una manera equivalente de plantear este problema es como un problema de algebra lineal, donde se tiene una matriz de observaciones <span class="math inline">\(X\)</span> que se construyen con las variables <span class="math inline">\(\mathbf x\)</span> de <span class="math inline">\(\mathcal X,\)</span> donde cada renglón de <span class="math inline">\(X\)</span> es una observación, y el vector dependiente <span class="math inline">\(\mathbf y\)</span> donde cada elemento es la respuesta correspondiente a la observación.</p>
<p>Viéndolo como un problema de algebra lineal lo que se tiene es</p>
<p><span class="math display">\[
X \mathbf w = \mathbf y,
\]</span></p>
<p>donde para identificar <span class="math inline">\(\mathbf w\)</span> se pueden realizar lo siguiente</p>
<p><span class="math display">\[
X^\intercal X \mathbf w = X^\intercal \mathbf y.
\]</span></p>
<p>Despejando <span class="math inline">\(\mathbf w\)</span> se tiene</p>
<p><span class="math display">\[
\mathbf w = (X^\intercal X)^{-1} X^\intercal \mathbf y.
\]</span></p>
<p>Previamente se ha presentado el error estándar de cada parámetro que se ha estimado, en caso de la regresión el error estándar (<a href="14Estadistica.html#sec-error-estandar-ols" class="quarto-xref"><span>Sección A.1.3</span></a>) de <span class="math inline">\(\mathcal w_j\)</span> es <span class="math inline">\(\sigma \sqrt{(X^\intercal X)^{-1}_{jj}}.\)</span></p>
<section id="sec-diabetes" class="level3" data-number="3.10.1">
<h3 data-number="3.10.1" class="anchored" data-anchor-id="sec-diabetes"><span class="header-section-number">3.10.1</span> Ejemplo: Diabetes</h3>
<p>Esta sección ilustra el proceso de resolver un problema de regresión utilizando OLS. El problema a resolver se obtiene mediante la función <code>load_diabetes</code> de la siguiente manera</p>
<div id="642437c7" class="cell" data-execution_count="44">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> load_diabetes(return_X_y<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El siguiente paso es generar los conjuntos de entrenamiento y prueba (<a href="#sec-conjunto-entre-prueba" class="quarto-xref"><span>Sección 3.5</span></a>)</p>
<div id="021904c8" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>T, G, y_t, y_g <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>                                  random_state<span class="op">=</span>seed)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Con el conjunto de entrenamiento <code>T</code> y <code>y_t</code> se estiman los parámetros de la regresión lineal tal y como se muestra a continuación</p>
<div id="11818cc7" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> LinearRegression().fit(T, y_t)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Los primeros tres coeficientes de la regresión lineal son <span class="math inline">\(\mathbf w=[-35.55, -243.17, 562.76, \ldots]\)</span> y <span class="math inline">\(w_0=152.54\)</span> lo cual se encuentran en las siguientes variables</p>
<div id="aa38dea4" class="cell" data-execution_count="48">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> m.coef_</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>w_0 <span class="op">=</span> m.intercept_</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La pregunta es si estos coeficientes son estadísticamente diferentes de cero, esto se puede conocer calculando el error estándar de cada coeficiente. Para lo cual se requiere estimar <span class="math inline">\(\sigma\)</span> que corresponde a la desviación estándar del error tal y como se muestra en las siguientes instrucciones.</p>
<div id="65927600" class="cell" data-execution_count="49">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> y_t <span class="op">-</span> m.predict(T)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>std_error <span class="op">=</span> np.std(error)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>El error estándar de <span class="math inline">\(\mathbf w\)</span> es</p>
<div id="3b861d56" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>diag <span class="op">=</span> np.arange(T.shape[<span class="dv">1</span>])</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> np.sqrt((np.dot(T.T, T)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span>))[diag, diag])</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> std_error <span class="op">*</span> _</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>y para saber si los coeficientes son significativamente diferente de cero se calcula el cociente <code>m.coef_</code> entre <code>se</code>; teniendo los siguientes valores <span class="math inline">\([-0.62, -4.17, 9.88, \ldots]\)</span>, para las tres primeras componentes. Se observa que hay varios coeficientes con valor absoluto menor que 2, lo cual significa que esas variables tiene un coeficiente que estadísticamente no es diferente de cero.</p>
<p>La predicción del conjunto de prueba se puede realizar con la siguiente instrucción</p>
<div id="36f0c7ea" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>hy <span class="op">=</span> m.predict(G)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finalmente, la <a href="#fig-regresion-lineal-scatter" class="quarto-xref">Figura&nbsp;<span>3.4</span></a> muestra las predicciones contra las mediciones reales. También se incluye la línea que ilustra el modelo ideal.</p>
<div id="cell-fig-regresion-lineal-scatter" class="cell" data-execution_count="53">
<details class="code-fold">
<summary>Código</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>hy, y<span class="op">=</span>y_g)</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>_min <span class="op">=</span> <span class="bu">min</span>(y_g.<span class="bu">min</span>(), hy.<span class="bu">min</span>())</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>_max <span class="op">=</span> <span class="bu">max</span>(y_g.<span class="bu">max</span>(), hy.<span class="bu">max</span>())</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.lineplot(x<span class="op">=</span>[_min, _max], y<span class="op">=</span>[_min, _max])</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-regresion-lineal-scatter" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-regresion-lineal-scatter-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="03Parametricos_files/figure-html/fig-regresion-lineal-scatter-output-1.png" width="572" height="410" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-regresion-lineal-scatter-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figura&nbsp;3.4: Regresión Lineal
</figcaption>
</figure>
</div>
</div>
</div>
<p>Complementando el ejemplo anterior, se realiza un modelo que primero elimina las variables que no son estadísticamente diferentes de cero (primera línea) y después crea nuevas variables al incluir el cuadrado, ver las líneas dos y tres del siguiente código.</p>
<div id="1aaa066a" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.fabs(m.coef_ <span class="op">/</span> se) <span class="op">&gt;=</span> <span class="dv">2</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> np.concatenate((T[:, mask], T[:, mask]<span class="op">**</span><span class="dv">2</span>), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> np.concatenate((G[:, mask], G[:, mask]<span class="op">**</span><span class="dv">2</span>), axis<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Se observa que la identificación de los coeficientes <span class="math inline">\(\mathbf w\)</span> sigue siendo lineal aun y cuando la representación ya no es lineal por incluir el cuadrado. Siguiendo los pasos descritos previamente, se inicializa el modelo y después se realiza la predicción.</p>
<div id="7c9bc3fe" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>m2 <span class="op">=</span> LinearRegression().fit(T, y_t)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>hy2 <span class="op">=</span> m2.predict(G)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En este momento se compara si la diferencia entre el error cuadrático medio, del primer y segundo modelo, la diferencia es <span class="math inline">\(8.9400\)</span> indicando que el primer modelo es mejor.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>diff <span class="op">=</span> ((y_g <span class="op">-</span> hy2)<span class="op">**</span><span class="dv">2</span>).mean() <span class="op">-</span>  ((y_g <span class="op">-</span> hy)<span class="op">**</span><span class="dv">2</span>).mean()</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Para comprobar si esta diferencia es significativa se calcula el error estándar, utilizando bootstrap (<a href="14Estadistica.html#sec-bootstrap" class="quarto-xref"><span>Sección A.2</span></a>) tal y como se muestra a continuación.</p>
<div id="030e19c0" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.random.randint(y_g.shape[<span class="dv">0</span>],</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>                      size<span class="op">=</span>(<span class="dv">500</span>, y_g.shape[<span class="dv">0</span>]))</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [((y_g[s] <span class="op">-</span> hy2[s])<span class="op">**</span><span class="dv">2</span>).mean() <span class="op">-</span></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>      ((y_g[s] <span class="op">-</span> hy[s])<span class="op">**</span><span class="dv">2</span>).mean()</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">for</span> s <span class="kw">in</span> S]</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(B, axis<span class="op">=</span><span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finalmente, se calcula el área bajo la curva a la izquierda del cero, teniendo un valor de <span class="math inline">\(0.4999\)</span> lo cual indica que los dos modelos son similares. En este caso se prefiere el modelo más simple porque se observar que incluir el cuadrado de las variables no contribuye a generar un mejor model. El área bajo la curva se calcula con el siguiente código.</p>
<div id="23336bac" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> norm(loc<span class="op">=</span>diff, scale<span class="op">=</span>se)</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> dist.cdf(<span class="dv">0</span>)</span></code><button title="Copiar al portapapeles" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


<!-- -->

</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ingeotec\.github\.io\/AprendizajeComputacional");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../capitulos/02Teoria_Decision.html" class="pagination-link" aria-label="Teoría de Decisión Bayesiana">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Teoría de Decisión Bayesiana</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../capitulos/04Rendimiento.html" class="pagination-link" aria-label="Rendimiento">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Rendimiento</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Ejecutar el código</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb51" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="fu"># Métodos Paramétricos {#sec-metodos-parametricos}</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>El **objetivo** de la unidad es conocer las características de los modelos paramétricos y aplicar máxima verosimilitud para estimar los parámetros del modelo paramétrico en problemas de regresión y clasificación.</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="fu">## Paquetes usados {.unnumbered}</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.discriminant_analysis <span class="im">import</span> QuadraticDiscriminantAnalysis</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.naive_bayes <span class="im">import</span> GaussianNB</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.linear_model <span class="im">import</span> LinearRegression</span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> load_breast_cancer,<span class="op">\</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>                             load_diabetes</span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.stats <span class="im">import</span> norm, multivariate_normal</span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.special <span class="im">import</span> logsumexp</span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> matplotlib <span class="im">import</span> pylab <span class="im">as</span> plt</span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb51-21"><a href="#cb51-21" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb51-22"><a href="#cb51-22" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb51-23"><a href="#cb51-23" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-24"><a href="#cb51-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-27"><a href="#cb51-27" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-28"><a href="#cb51-28" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-29"><a href="#cb51-29" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.display <span class="im">import</span> Markdown</span>
<span id="cb51-30"><a href="#cb51-30" aria-hidden="true" tabindex="-1"></a>np.set_printoptions(precision<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb51-31"><a href="#cb51-31" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-32"><a href="#cb51-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-33"><a href="#cb51-33" aria-hidden="true" tabindex="-1"></a>::: {.content-visible when-format="html"}</span>
<span id="cb51-34"><a href="#cb51-34" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb51-35"><a href="#cb51-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-36"><a href="#cb51-36" aria-hidden="true" tabindex="-1"></a>{{&lt; video https://www.youtube.com/embed/Tlwecs3dUPw width="560" height="315" &gt;}}</span>
<span id="cb51-37"><a href="#cb51-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-38"><a href="#cb51-38" aria-hidden="true" tabindex="-1"></a>---</span>
<span id="cb51-39"><a href="#cb51-39" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-40"><a href="#cb51-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-41"><a href="#cb51-41" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introducción {#sec-intro-03}</span></span>
<span id="cb51-42"><a href="#cb51-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-43"><a href="#cb51-43" aria-hidden="true" tabindex="-1"></a>Existen diferentes tipos de algoritmos que se puede utilizar para resolver problemas de aprendizaje supervisado y no supervisado. En particular, esta unidad se enfoca en presentar las técnicas que se pueden caracterizar como métodos paramétricos. </span>
<span id="cb51-44"><a href="#cb51-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-45"><a href="#cb51-45" aria-hidden="true" tabindex="-1"></a>Los métodos paramétricos se identifican por asumir que los datos provienen de una distribución de la cual se desconocen los parámetros y el procedimiento es encontrar los parámetros de la distribución que mejor modelen los datos. Una vez obtenidos los parámetros se cuenta con todos los elementos para utilizar el modelo y predecir la característica para la cual fue entrenada. </span>
<span id="cb51-46"><a href="#cb51-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-47"><a href="#cb51-47" aria-hidden="true" tabindex="-1"></a><span class="fu">## Metodología {#sec-metodologia-met-parametricos}</span></span>
<span id="cb51-48"><a href="#cb51-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-49"><a href="#cb51-49" aria-hidden="true" tabindex="-1"></a>Hasta el momento se han presentado ejemplos de los pasos 4 y 5 de la metodología general (ver @sec-metodologia-general); esto fue en la @sec-prediccion-normal y en la @sec-error-clasificacion. Esta sección complementa los ejemplos anteriores al utilizar todos pasos de la metodología general de aprendizaje supervisado (ver @sec-metodologia-general). En particular se enfoca al paso 3 que corresponde al diseño del algoritmo $f$ que modela el fenómeno de interés utilizando los datos $\mathcal T \subset \mathcal D.$</span>
<span id="cb51-50"><a href="#cb51-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-51"><a href="#cb51-51" aria-hidden="true" tabindex="-1"></a>El algoritmo $f$ corresponde a asumir que los datos $\mathcal D$ provienen de </span>
<span id="cb51-52"><a href="#cb51-52" aria-hidden="true" tabindex="-1"></a>una distribución $F$ la cual tiene una serie de parámetros $\theta$ que </span>
<span id="cb51-53"><a href="#cb51-53" aria-hidden="true" tabindex="-1"></a>son identificados con $\mathcal T.$</span>
<span id="cb51-54"><a href="#cb51-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-55"><a href="#cb51-55" aria-hidden="true" tabindex="-1"></a><span class="fu">## Estimación de Parámetros {#sec-estimacion-parametros-gnal}</span></span>
<span id="cb51-56"><a href="#cb51-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-57"><a href="#cb51-57" aria-hidden="true" tabindex="-1"></a>Se inicia la descripción de métodos paramétricos presentando el procedimiento general para estimar los parámetros de una distribución. Se cuenta con un conjunto $\mathcal D$ donde los elementos $x \in \mathcal D$ son $x \in \mathbb R^d$. Los elementos $x \in \mathcal D$ tienen un distribución $F$, i.e., $x \sim F$, son independientes y $F$ está definida por la función de densidad de probabilidad $f_{\theta}$, que a su vez está definida por $\theta$ parámetros. Utilizando $\mathcal D$ el objetivo es identificar los parámetros $\theta$ que hacen observar a $\mathcal D$ lo más probable. </span>
<span id="cb51-58"><a href="#cb51-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-59"><a href="#cb51-59" aria-hidden="true" tabindex="-1"></a><span class="fu">### Verosimilitud {#sec-verosimilitud}</span></span>
<span id="cb51-60"><a href="#cb51-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-61"><a href="#cb51-61" aria-hidden="true" tabindex="-1"></a>Una solución para maximizar el observar $\mathcal D$ es maximizando la verosimilitud. La verosimilitud es la función distribución conjunta de los elementos en $\mathcal D$, i.e., $f_\theta(x_1, x_2, \ldots, x_N).$ Considerando que la muestras son independientes entonces $f_\theta(x_1, x_2, \ldots, x_N) = \prod_{x \in \mathcal D} f_\theta (x).$ La función de verosimilitud considera la ecuación anterior como una función de los parámetros $\theta,$ es decir,</span>
<span id="cb51-62"><a href="#cb51-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-63"><a href="#cb51-63" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-64"><a href="#cb51-64" aria-hidden="true" tabindex="-1"></a>\mathcal L(\theta) = \prod_{x \in \mathcal D} f_\theta (x),</span>
<span id="cb51-65"><a href="#cb51-65" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-66"><a href="#cb51-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-67"><a href="#cb51-67" aria-hidden="true" tabindex="-1"></a>siendo el logaritmo de la verosimilitud </span>
<span id="cb51-68"><a href="#cb51-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-69"><a href="#cb51-69" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-70"><a href="#cb51-70" aria-hidden="true" tabindex="-1"></a>\ell(\theta) = \log \mathcal L(\theta) = \sum_{x \in \mathcal D} \log f_\theta (x).</span>
<span id="cb51-71"><a href="#cb51-71" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-72"><a href="#cb51-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-73"><a href="#cb51-73" aria-hidden="true" tabindex="-1"></a><span class="fu">### Distribución de Bernoulli {#sec-distribucción-de-bernoulli}</span></span>
<span id="cb51-74"><a href="#cb51-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-75"><a href="#cb51-75" aria-hidden="true" tabindex="-1"></a>La verosimilitud se ejemplifica con la identificación del parámetro $p$ de una distribución Bernoulli. Una distribución Bernoulli modela dos estados, por un lado se tiene la clase negativa identificada por $0$; identificando la clase positiva como $1$. Entonces, la probabilidad de observar $1$ es $\mathbb P(X=1) = p$ y $\mathbb P(X=0) = 1 - p$. Estas ecuaciones se pueden combinar para definir $f_\theta(x) = p^x (1 - p)^{1-x}.$</span>
<span id="cb51-76"><a href="#cb51-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-77"><a href="#cb51-77" aria-hidden="true" tabindex="-1"></a>Utilizando el logaritmo de la verosimilitud se tiene:</span>
<span id="cb51-78"><a href="#cb51-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-79"><a href="#cb51-79" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-80"><a href="#cb51-80" aria-hidden="true" tabindex="-1"></a>\ell(p) = \sum_{i=1}^N \log p^{x_i} (1 - p)^{1-x_i} = \sum_{i=1}^N x_i \log p + (1-x_i) \log (1 - p).</span>
<span id="cb51-81"><a href="#cb51-81" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-82"><a href="#cb51-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-83"><a href="#cb51-83" aria-hidden="true" tabindex="-1"></a>Recordando que el máximo de $\ell(\mathcal p)$ se obtiene cuando $\frac{d}{dp} \ell(\mathcal p) = 0$, entonces estimar $p$ corresponde a resolver lo siguiente:</span>
<span id="cb51-84"><a href="#cb51-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-85"><a href="#cb51-85" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-86"><a href="#cb51-86" aria-hidden="true" tabindex="-1"></a>\begin{split}</span>
<span id="cb51-87"><a href="#cb51-87" aria-hidden="true" tabindex="-1"></a>\frac{d}{dp} \ell(\mathcal p) &amp;= 0 <span class="sc">\\</span></span>
<span id="cb51-88"><a href="#cb51-88" aria-hidden="true" tabindex="-1"></a>\frac{d}{dp} <span class="co">[</span><span class="ot"> \sum_{i=1}^N x_i \log p + (1-x_i) \log (1 - p)</span><span class="co">]</span> &amp;= 0 <span class="sc">\\</span> </span>
<span id="cb51-89"><a href="#cb51-89" aria-hidden="true" tabindex="-1"></a>\frac{d}{d p} <span class="co">[</span><span class="ot"> \sum_{i=1}^N x_i \log p + \log (1 - p) (N - \sum_{i=1}^N x_i) </span><span class="co">]</span> &amp;= 0<span class="sc">\\</span></span>
<span id="cb51-90"><a href="#cb51-90" aria-hidden="true" tabindex="-1"></a>\sum_{i=1}^N x_i \frac{d}{d p} \log \mathcal p + (N - \sum_{i=1}^N x_i) \frac{d}{d p} \log (1 - \mathcal p) &amp;= 0<span class="sc">\\</span> </span>
<span id="cb51-91"><a href="#cb51-91" aria-hidden="true" tabindex="-1"></a>\sum_{i=1}^N x_i \frac{1}{p} + (N - \sum_{i=1}^N x_i) \frac{-1}{(1 - p)} &amp;= 0<span class="sc">\\</span> </span>
<span id="cb51-92"><a href="#cb51-92" aria-hidden="true" tabindex="-1"></a>\end{split}</span>
<span id="cb51-93"><a href="#cb51-93" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-94"><a href="#cb51-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-95"><a href="#cb51-95" aria-hidden="true" tabindex="-1"></a>Realizando algunas operaciones algebraicas se obtiene:</span>
<span id="cb51-96"><a href="#cb51-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-97"><a href="#cb51-97" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-98"><a href="#cb51-98" aria-hidden="true" tabindex="-1"></a>\hat p = \frac{1}{N}\sum_{i=1}^N x_i.</span>
<span id="cb51-99"><a href="#cb51-99" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-100"><a href="#cb51-100" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-101"><a href="#cb51-101" aria-hidden="true" tabindex="-1"></a><span class="fu">### Ejemplo: Distribución Gausiana {#sec-estimacion-distribucion-gausiana}</span></span>
<span id="cb51-102"><a href="#cb51-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-103"><a href="#cb51-103" aria-hidden="true" tabindex="-1"></a>Esta sección sigue un camino práctico, presentando el código para estimar los parámetros de una distribución Gausiana donde se conocen todos los parámetros. La distribución se usa para generar 1000 muestras y después de esta población se estiman los parámetros; de estas manera se tienen todos los elementos para comparar los parámetros reales $\theta$ de los parámetros estimados $\hat \theta.$</span>
<span id="cb51-104"><a href="#cb51-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-105"><a href="#cb51-105" aria-hidden="true" tabindex="-1"></a>La distribución que se usará se utilizó para generar un problema sintético (ver @sec-tres-normales) de tres clases. Los parámetros de la distribución son: $\mathbf \mu = <span class="co">[</span><span class="ot">5, 5</span><span class="co">]</span>^\intercal$ y  $\Sigma = \begin{pmatrix} 4 &amp; 0 <span class="sc">\\</span> 0 &amp; 2 <span class="sc">\\</span> \end{pmatrix}.$ La siguiente instrucción se puede utilizar para generar 1000 muestras de esa distribución. </span>
<span id="cb51-106"><a href="#cb51-106" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-109"><a href="#cb51-109" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-110"><a href="#cb51-110" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-111"><a href="#cb51-111" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="dv">5</span>, <span class="dv">5</span>], </span>
<span id="cb51-112"><a href="#cb51-112" aria-hidden="true" tabindex="-1"></a>                        cov<span class="op">=</span>[[<span class="dv">4</span>, <span class="dv">0</span>], </span>
<span id="cb51-113"><a href="#cb51-113" aria-hidden="true" tabindex="-1"></a>                             [<span class="dv">0</span>, <span class="dv">2</span>]]).rvs(size<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb51-114"><a href="#cb51-114" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-115"><a href="#cb51-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-116"><a href="#cb51-116" aria-hidden="true" tabindex="-1"></a>La media estimada de los datos en <span class="in">`D`</span> se calcula usando la función <span class="in">`np.mean`</span> de la siguiente manera</span>
<span id="cb51-117"><a href="#cb51-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-120"><a href="#cb51-120" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-121"><a href="#cb51-121" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-122"><a href="#cb51-122" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> np.mean(D, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-123"><a href="#cb51-123" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-124"><a href="#cb51-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-127"><a href="#cb51-127" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-128"><a href="#cb51-128" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-129"><a href="#cb51-129" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="st">', '</span>.join([<span class="ss">f'</span><span class="sc">{</span>x<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> mu])</span>
<span id="cb51-130"><a href="#cb51-130" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(D, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> np.sqrt(<span class="dv">1000</span>)</span>
<span id="cb51-131"><a href="#cb51-131" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> <span class="st">', '</span>.join([<span class="ss">f'</span><span class="sc">{</span>x<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> x <span class="kw">in</span> se])</span>
<span id="cb51-132"><a href="#cb51-132" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"donde el eje de operación es el primero que corresponde al índice $0.$ La media estimada es: $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">mu = [</span><span class="sc">{</span>mu<span class="sc">}</span><span class="ss">]^</span><span class="ch">\\</span><span class="ss">intercal$ con un [error estándar](ver @sec-error-estandar-media) (`se`) de $[</span><span class="sc">{</span>se<span class="sc">}</span><span class="ss">]^</span><span class="ch">\\</span><span class="ss">intercal$ que se calcula con el siguiente código."</span>)</span>
<span id="cb51-133"><a href="#cb51-133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-134"><a href="#cb51-134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-137"><a href="#cb51-137" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-138"><a href="#cb51-138" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-139"><a href="#cb51-139" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(D, axis<span class="op">=</span><span class="dv">0</span>) <span class="op">/</span> np.sqrt(<span class="dv">1000</span>)</span>
<span id="cb51-140"><a href="#cb51-140" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-141"><a href="#cb51-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-142"><a href="#cb51-142" aria-hidden="true" tabindex="-1"></a>Hasta el momento se ha estimado $\mu$, falta por estimar $\Sigma$, que se puede realizar con la siguiente instrucción</span>
<span id="cb51-143"><a href="#cb51-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-146"><a href="#cb51-146" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-147"><a href="#cb51-147" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-148"><a href="#cb51-148" aria-hidden="true" tabindex="-1"></a>cov <span class="op">=</span> np.cov(D, rowvar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb51-149"><a href="#cb51-149" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-150"><a href="#cb51-150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-153"><a href="#cb51-153" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-154"><a href="#cb51-154" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-155"><a href="#cb51-155" aria-hidden="true" tabindex="-1"></a>a, b <span class="op">=</span> [<span class="st">'&amp;'</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> col]) <span class="cf">for</span> col <span class="kw">in</span> cov]</span>
<span id="cb51-156"><a href="#cb51-156" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"donde el parámetro `rowvar` indica la forma en que están proporcionados los datos. La estimación da los siguientes valores $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma = </span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">;$ se puede observar que son similares al parámetro con que se simularon los datos."</span>)</span>
<span id="cb51-157"><a href="#cb51-157" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-158"><a href="#cb51-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-159"><a href="#cb51-159" aria-hidden="true" tabindex="-1"></a>Siguiendo con la inercia de presentar el error estándar de cada estimación, en las siguientes instrucciones se presenta el error estándar de $\hat \Sigma$, el cual se calcula utilizando la técnica de bootstrap (ver @sec-bootstrap) implementada en el siguiente código. </span>
<span id="cb51-160"><a href="#cb51-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-163"><a href="#cb51-163" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-164"><a href="#cb51-164" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-165"><a href="#cb51-165" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.random.randint(D.shape[<span class="dv">0</span>],</span>
<span id="cb51-166"><a href="#cb51-166" aria-hidden="true" tabindex="-1"></a>                      size<span class="op">=</span>(<span class="dv">500</span>, D.shape[<span class="dv">0</span>]))</span>
<span id="cb51-167"><a href="#cb51-167" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [np.cov(D[s], rowvar<span class="op">=</span><span class="va">False</span>) <span class="cf">for</span> s <span class="kw">in</span> S]</span>
<span id="cb51-168"><a href="#cb51-168" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(B, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-169"><a href="#cb51-169" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-170"><a href="#cb51-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-173"><a href="#cb51-173" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-174"><a href="#cb51-174" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-175"><a href="#cb51-175" aria-hidden="true" tabindex="-1"></a>a, b <span class="op">=</span> [<span class="st">'&amp;'</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> col]) <span class="cf">for</span> col <span class="kw">in</span> se]</span>
<span id="cb51-176"><a href="#cb51-176" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"Se puede observar que la función `np.cov` se ejecuta utilizando la muestra indicada en la variable `s`. El error estándar (`se`) de $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma$ corresponde a $</span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>a<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">.$ Se observa que los elementos fuera de la diagonal tienen un error estándar tal que el cero se encuentra en el intervalo $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma </span><span class="ch">\\</span><span class="ss">pm se;$ lo cual indica que el cero es un valor factible. Lo anterior se puede verificar tomando en cuenta que se conoce $</span><span class="ch">\\</span><span class="ss">Sigma$ y que el parámetro real es $0$ para aquellos elementos fuera de la diagonal."</span>)</span>
<span id="cb51-177"><a href="#cb51-177" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-178"><a href="#cb51-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-179"><a href="#cb51-179" aria-hidden="true" tabindex="-1"></a><span class="fu">## Metodología de Clasificación</span></span>
<span id="cb51-180"><a href="#cb51-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-181"><a href="#cb51-181" aria-hidden="true" tabindex="-1"></a>Habiendo descrito el proceso para estimar los parámetros de una distribución, por un lado se presentó de manera teórica con la distribución Bernoulli (ver @sec-distribucción-de-bernoulli) y de manera práctica con una distribución Gausiana (ver @sec-estimacion-distribucion-gausiana), se está en la posición de usar todos estos elementos para presentar el proceso completo de clasificación. La metodología general de aprendizaje supervisado (ver @sec-metodologia-general) está definida por cinco pasos, estos pasos se especializan para el problema de clasificación y regresión, utilizando modelos paramétricos, de la siguiente manera. </span>
<span id="cb51-182"><a href="#cb51-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-183"><a href="#cb51-183" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Todo empieza con un conjunto de datos $\mathcal D$ que tiene la información del fenómeno de interés.</span>
<span id="cb51-184"><a href="#cb51-184" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Se selecciona el conjunto $\mathcal T \subset \mathcal D,$ el procedimiento se describe en la @sec-conjunto-entre-prueba. </span>
<span id="cb51-185"><a href="#cb51-185" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Se diseña un algoritmo, $f$, el cual se basa en un modelo (ver @sec-model-clasificacion) y la estimación de sus parámetros (ver @sec-estimacion-parametros) utilizando $\mathcal T.$</span>
<span id="cb51-186"><a href="#cb51-186" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>En la @sec-prediccion se describe el uso de $f$ para predecir.</span>
<span id="cb51-187"><a href="#cb51-187" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>La @sec-rendimiento muestra el procedimiento para medir el rendimiento utilizando un conjunto de prueba (ver @sec-conjunto-entre-prueba).</span>
<span id="cb51-188"><a href="#cb51-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-189"><a href="#cb51-189" aria-hidden="true" tabindex="-1"></a>La metodología de clasificación se ilustra utilizando el problema sintético (ver @sec-tres-normales) de tres clases que se presentó en el @sec-teoria-decision-bayesianas. </span>
<span id="cb51-190"><a href="#cb51-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-191"><a href="#cb51-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-192"><a href="#cb51-192" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb51-193"><a href="#cb51-193" aria-hidden="true" tabindex="-1"></a><span class="fu">### Problema sintético  </span></span>
<span id="cb51-196"><a href="#cb51-196" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-197"><a href="#cb51-197" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb51-198"><a href="#cb51-198" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-199"><a href="#cb51-199" aria-hidden="true" tabindex="-1"></a>seed <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb51-200"><a href="#cb51-200" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="dv">5</span>, <span class="dv">5</span>],</span>
<span id="cb51-201"><a href="#cb51-201" aria-hidden="true" tabindex="-1"></a>                         cov<span class="op">=</span>[[<span class="dv">4</span>, <span class="dv">0</span>], [<span class="dv">0</span>, <span class="dv">2</span>]],</span>
<span id="cb51-202"><a href="#cb51-202" aria-hidden="true" tabindex="-1"></a>                         seed<span class="op">=</span>seed)</span>
<span id="cb51-203"><a href="#cb51-203" aria-hidden="true" tabindex="-1"></a>p2 <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="fl">1.5</span>, <span class="op">-</span><span class="fl">1.5</span>],</span>
<span id="cb51-204"><a href="#cb51-204" aria-hidden="true" tabindex="-1"></a>                         cov<span class="op">=</span>[[<span class="dv">2</span>, <span class="dv">1</span>], [<span class="dv">1</span>, <span class="dv">3</span>]],</span>
<span id="cb51-205"><a href="#cb51-205" aria-hidden="true" tabindex="-1"></a>                         seed<span class="op">=</span>seed)</span>
<span id="cb51-206"><a href="#cb51-206" aria-hidden="true" tabindex="-1"></a>p3 <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>[<span class="fl">12.5</span>, <span class="op">-</span><span class="fl">3.5</span>], </span>
<span id="cb51-207"><a href="#cb51-207" aria-hidden="true" tabindex="-1"></a>                         cov<span class="op">=</span>[[<span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">3</span>, <span class="dv">7</span>]],</span>
<span id="cb51-208"><a href="#cb51-208" aria-hidden="true" tabindex="-1"></a>                         seed<span class="op">=</span>seed)</span>
<span id="cb51-209"><a href="#cb51-209" aria-hidden="true" tabindex="-1"></a>X_1 <span class="op">=</span> p1.rvs(size<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb51-210"><a href="#cb51-210" aria-hidden="true" tabindex="-1"></a>X_2 <span class="op">=</span> p2.rvs(size<span class="op">=</span><span class="dv">1000</span>)</span>
<span id="cb51-211"><a href="#cb51-211" aria-hidden="true" tabindex="-1"></a>X_3 <span class="op">=</span> p3.rvs(size<span class="op">=</span><span class="dv">1000</span>)                         </span>
<span id="cb51-212"><a href="#cb51-212" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-213"><a href="#cb51-213" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-214"><a href="#cb51-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-215"><a href="#cb51-215" aria-hidden="true" tabindex="-1"></a>Específicamente, las entradas que definían a cada clase están en la variables <span class="in">`X_1`</span>, <span class="in">`X_2`</span> y <span class="in">`X_3`</span>. Entonces las clases se pueden colocar en la variable <span class="in">`y`</span> tal como se indica a continuación. </span>
<span id="cb51-216"><a href="#cb51-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-217"><a href="#cb51-217" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-220"><a href="#cb51-220" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-221"><a href="#cb51-221" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-222"><a href="#cb51-222" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> np.concatenate((X_1, X_2, X_3))</span>
<span id="cb51-223"><a href="#cb51-223" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.array([<span class="dv">1</span>] <span class="op">*</span> <span class="dv">1000</span> <span class="op">+</span> [<span class="dv">2</span>] <span class="op">*</span> <span class="dv">1000</span> <span class="op">+</span> [<span class="dv">3</span>] <span class="op">*</span> <span class="dv">1000</span>)</span>
<span id="cb51-224"><a href="#cb51-224" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-225"><a href="#cb51-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-226"><a href="#cb51-226" aria-hidden="true" tabindex="-1"></a>Las variables <span class="in">`X`</span> y <span class="in">`y`</span> contiene la información del conjunto $\mathcal D = (\mathcal X, \mathcal Y)$ donde cada renglón de <span class="in">`X`</span> es una realización de la variable aleatoria $\mathcal X$ y equivalentemente cada elemento en <span class="in">`y`</span> es una realización de $\mathcal Y.$</span>
<span id="cb51-227"><a href="#cb51-227" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-228"><a href="#cb51-228" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conjunto de Entrenamiento y Prueba {#sec-conjunto-entre-prueba}</span></span>
<span id="cb51-229"><a href="#cb51-229" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-230"><a href="#cb51-230" aria-hidden="true" tabindex="-1"></a>En la @sec-estimacion-distribucion-gausiana se había utilizado a $\mathcal D$ en el procedimiento de maximizar la verosimilitud, esto porque el objetivo en ese procedimiento era estimar los parámetros de la distribución. Pero el objetivo en aprendizaje supervisado es diseñar un algoritmo (función en este caso) que modele la relación entre $\mathcal X$ y $\mathcal Y$. Para conocer esto es necesario medir el rendimiento del algoritmo en instancias que no han sido vistas en el entrenamiento.</span>
<span id="cb51-231"><a href="#cb51-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-232"><a href="#cb51-232" aria-hidden="true" tabindex="-1"></a>En consecuencia, se requieren contar con datos para medir el rendimiento, a este conjunto de datos se le conoce como el conjunto de prueba, $\mathcal G$. $\mathcal G$ se crea a partir de $\mathcal D$ de tal manera que $\mathcal G \cap \mathcal T = \emptyset$ y $\mathcal D =  \mathcal G \cup \mathcal T.$ La siguiente instrucción se puede utilizar para dividir la generación de estos conjuntos a partir de $\mathcal D.$</span>
<span id="cb51-233"><a href="#cb51-233" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-236"><a href="#cb51-236" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-237"><a href="#cb51-237" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-238"><a href="#cb51-238" aria-hidden="true" tabindex="-1"></a>T, G, y_t, y_g <span class="op">=</span> train_test_split(X, y,</span>
<span id="cb51-239"><a href="#cb51-239" aria-hidden="true" tabindex="-1"></a>                                  test_size<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb51-240"><a href="#cb51-240" aria-hidden="true" tabindex="-1"></a>                                  random_state<span class="op">=</span>seed)</span>
<span id="cb51-241"><a href="#cb51-241" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-242"><a href="#cb51-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-243"><a href="#cb51-243" aria-hidden="true" tabindex="-1"></a>El parámetro <span class="in">`test_size`</span> indica la proporción del tamaño de conjunto $\mathcal G$ en relación con el conjunto $\mathcal D.$</span>
<span id="cb51-244"><a href="#cb51-244" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-245"><a href="#cb51-245" aria-hidden="true" tabindex="-1"></a><span class="fu">## Clasificador {#sec-model-clasificacion}</span></span>
<span id="cb51-246"><a href="#cb51-246" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-247"><a href="#cb51-247" aria-hidden="true" tabindex="-1"></a>El inicio de métodos paramétricos es el Teorema de Bayes (@eq-teorema-bayes) $\mathbb P(\mathcal Y \mid \mathcal X) = \frac{ \mathbb P(\mathcal X \mid \mathcal Y) \mathbb P(\mathcal Y)}{\mathbb P(\mathcal X)}$ donde se usa la verosimilitud $\mathbb P(\mathcal X \mid \mathcal Y)$ y el prior $\mathbb P(\mathcal Y)$ para definir la probabilidad a posteriori $\mathbb P(\mathcal Y \mid \mathcal X)$. En métodos paramétricos se asume que se puede modelar la verosimilitud con una distribución particular, que por lo generar es una distribución Gausiana multivariada. Es decir, la variable aleatoria $\mathcal X$ dado $\mathcal Y$ (i.e., $\mathcal X_{\mid \mathcal Y}$) es $\mathcal X_{\mid \mathcal Y} \sim \mathcal N(\mu_{\mathcal Y}, \Sigma_{\mathcal Y}),$ donde se observa que los parámetros de la distribución Gausiana dependen de la variable aleatoria $\mathcal Y$ y estos pueden ser identificados cuando $\mathcal Y$ tiene un valor específico. </span>
<span id="cb51-248"><a href="#cb51-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-249"><a href="#cb51-249" aria-hidden="true" tabindex="-1"></a><span class="fu">### Estimación de Parámetros {#sec-estimacion-parametros}</span></span>
<span id="cb51-250"><a href="#cb51-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-251"><a href="#cb51-251" aria-hidden="true" tabindex="-1"></a>Dado que por definición del problema (ver @sec-tres-normales) se conoce que la verosimilitud para cada clase proviene de una Gausiana, i.e., $\mathcal X_{\mid \mathcal Y} \sim \mathcal N(\mu_{\mathcal Y}, \Sigma_{\mathcal Y}),$ en esta sección se estimarán los parámetros utilizando este conocimiento. </span>
<span id="cb51-252"><a href="#cb51-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-253"><a href="#cb51-253" aria-hidden="true" tabindex="-1"></a>El primer paso en la estimación de parámetros es calcular el prior $\mathbb P(\mathcal Y)$, el cual corresponde a clasificar el evento sin observar el valor de $\mathcal X.$ Esto se puede modelar mediante una distribución Categórica con parámetros $p_i$ donde $\sum_i^K p_i = 1$. Estos parámetros se pueden estimar utilizando la función <span class="in">`np.unique`</span> de la siguiente manera</span>
<span id="cb51-254"><a href="#cb51-254" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-257"><a href="#cb51-257" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-258"><a href="#cb51-258" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-259"><a href="#cb51-259" aria-hidden="true" tabindex="-1"></a>labels, counts <span class="op">=</span> np.unique(y_t, return_counts<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb51-260"><a href="#cb51-260" aria-hidden="true" tabindex="-1"></a>prior <span class="op">=</span> counts <span class="op">/</span> counts.<span class="bu">sum</span>()</span>
<span id="cb51-261"><a href="#cb51-261" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-262"><a href="#cb51-262" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-263"><a href="#cb51-263" aria-hidden="true" tabindex="-1"></a>La variable <span class="in">`prior`</span> contiene en el primer elemento <span class="in">`{python} Markdown(f'$\mathbb P(\mathcal Y=1) = {prior[0]:0.4f},$')`</span> en el segundo <span class="in">`{python} Markdown(f'$\mathbb P(\mathcal Y=2) = {prior[1]:0.4f}$')`</span> y en el tercero <span class="in">`{python} Markdown(f'$\mathbb P(\mathcal Y=3) = {prior[2]:0.4f}$')`</span> que es aproximadamente $\frac{1}{3}$ el cual es el valor real del prior. </span>
<span id="cb51-264"><a href="#cb51-264" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-265"><a href="#cb51-265" aria-hidden="true" tabindex="-1"></a>Siguiendo los pasos en estimación de parámetros de una Gausiana (@sec-estimacion-distribucion-gausiana) se pueden estimar los parámetros para cada Gausiana dada la clase. Es decir, se tiene que estimar los parámetros $\mu$ y $\Sigma$ para la clase $1$, $2$ y $3.$ El algoritmo de clasificación que estima $\mu$ y $\Sigma$ para cada clase se le conoce como **Analizador Discriminante Cuadrático** implementando en la clase <span class="in">`QuadraticDiscriminantAnalysis`</span>.</span>
<span id="cb51-266"><a href="#cb51-266" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-267"><a href="#cb51-267" aria-hidden="true" tabindex="-1"></a>Una implementación directa para la estimación de los parámetros se puede realizar iterando por las etiquetas contenidas en la variable <span class="in">`labels`</span> y seleccionando los datos en <span class="in">`T`</span> que corresponden a la clase analizada, ver el uso de la variable <span class="in">`mask`</span> en el slice de la línea 4 y 5. Después se inicializa una instancia de la clase <span class="in">`multivariate_normal`</span> para ser utilizada en el cómputo de la función de densidad de probabilidad. El paso final es guardar las instancias de las distribuciones en la lista <span class="in">`likelihood`</span>.</span>
<span id="cb51-268"><a href="#cb51-268" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-269"><a href="#cb51-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-272"><a href="#cb51-272" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-273"><a href="#cb51-273" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-274"><a href="#cb51-274" aria-hidden="true" tabindex="-1"></a>likelihood <span class="op">=</span> []</span>
<span id="cb51-275"><a href="#cb51-275" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> labels:</span>
<span id="cb51-276"><a href="#cb51-276" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y_t <span class="op">==</span> k</span>
<span id="cb51-277"><a href="#cb51-277" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> np.mean(T[mask], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-278"><a href="#cb51-278" aria-hidden="true" tabindex="-1"></a>    cov <span class="op">=</span> np.cov(T[mask], rowvar<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb51-279"><a href="#cb51-279" aria-hidden="true" tabindex="-1"></a>    likelihood_k <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>mu, cov<span class="op">=</span>cov)</span>
<span id="cb51-280"><a href="#cb51-280" aria-hidden="true" tabindex="-1"></a>    likelihood.append(likelihood_k)</span>
<span id="cb51-281"><a href="#cb51-281" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-282"><a href="#cb51-282" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-285"><a href="#cb51-285" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-286"><a href="#cb51-286" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-287"><a href="#cb51-287" aria-hidden="true" tabindex="-1"></a>mus <span class="op">=</span> [<span class="st">', '</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> li.mean]) <span class="cf">for</span> li <span class="kw">in</span> likelihood]</span>
<span id="cb51-288"><a href="#cb51-288" aria-hidden="true" tabindex="-1"></a>mm <span class="op">=</span> []</span>
<span id="cb51-289"><a href="#cb51-289" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> cov <span class="kw">in</span> likelihood:</span>
<span id="cb51-290"><a href="#cb51-290" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> [<span class="st">' &amp; '</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> reg]) <span class="cf">for</span> reg <span class="kw">in</span> cov.cov]</span>
<span id="cb51-291"><a href="#cb51-291" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> <span class="st">'</span><span class="ch">\\\\</span><span class="st">'</span>.join(_)</span>
<span id="cb51-292"><a href="#cb51-292" aria-hidden="true" tabindex="-1"></a>    mm.append(_)</span>
<span id="cb51-293"><a href="#cb51-293" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"Los valores estimados para la media, en cada clase son: $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">mu_1 = [</span><span class="sc">{</span>mus[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">]^</span><span class="ch">\\</span><span class="ss">intercal,$ $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">mu_2 = [</span><span class="sc">{</span>mus[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">]^</span><span class="ch">\\</span><span class="ss">intercal$ y $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">mu_3 = [</span><span class="sc">{</span>mus[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">]^</span><span class="ch">\\</span><span class="ss">intercal$. Para las matrices de covarianza, los valores estimados corresponden a $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma_1 = </span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>mm[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">,$ $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma_2 = </span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>mm[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">$ y $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma_3 = </span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>mm[<span class="dv">2</span>]<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">.$"</span>)</span>
<span id="cb51-294"><a href="#cb51-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-295"><a href="#cb51-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-296"><a href="#cb51-296" aria-hidden="true" tabindex="-1"></a>Estas estimaciones se pueden comparar con los parámetros reales (@sec-tres-normales). También se puede calcular su error estándar para identificar si el parámetro real, $\theta$, se encuentra en el intervalo definido por $\hat \theta - 2\hat{se} \leq \hat \theta \leq \hat \theta + 2 \hat{se}$ que corresponde aproximadamente al 95% de confianza asumiendo que la distribución de la estimación del parámetro es Gausiana.</span>
<span id="cb51-297"><a href="#cb51-297" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-298"><a href="#cb51-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-299"><a href="#cb51-299" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb51-300"><a href="#cb51-300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-301"><a href="#cb51-301" aria-hidden="true" tabindex="-1"></a>El código anterior tiene el fin de explicar el procedimiento para estimar los parámetros, la clase <span class="in">`QuadraticDiscriminantAnalysis`</span> implementa diferentes métodos de estimación y se puede utilizar con el siguiente código. </span>
<span id="cb51-302"><a href="#cb51-302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-305"><a href="#cb51-305" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-306"><a href="#cb51-306" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-307"><a href="#cb51-307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-308"><a href="#cb51-308" aria-hidden="true" tabindex="-1"></a>qda <span class="op">=</span> QuadraticDiscriminantAnalysis(store_covariance<span class="op">=</span><span class="va">True</span>).fit(T, y_t)</span>
<span id="cb51-309"><a href="#cb51-309" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-310"><a href="#cb51-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-311"><a href="#cb51-311" aria-hidden="true" tabindex="-1"></a>Los parámetros $\mu$ se encuentran en el siguiente atributo. Se puede observar que los valores estimados por el método explicado y el implementado en QDA es el mismo. </span>
<span id="cb51-312"><a href="#cb51-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-315"><a href="#cb51-315" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-316"><a href="#cb51-316" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-317"><a href="#cb51-317" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-318"><a href="#cb51-318" aria-hidden="true" tabindex="-1"></a>qda.means_</span>
<span id="cb51-319"><a href="#cb51-319" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-320"><a href="#cb51-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-321"><a href="#cb51-321" aria-hidden="true" tabindex="-1"></a>Los parámetros estimados para $\Sigma_1$ se pueden obtener en el siguiente atributo</span>
<span id="cb51-324"><a href="#cb51-324" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-325"><a href="#cb51-325" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-326"><a href="#cb51-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-327"><a href="#cb51-327" aria-hidden="true" tabindex="-1"></a>qda.covariance_[<span class="dv">0</span>]</span>
<span id="cb51-328"><a href="#cb51-328" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-329"><a href="#cb51-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-330"><a href="#cb51-330" aria-hidden="true" tabindex="-1"></a>Se observa que los valores son equivalentes entre los dos procedimientos, es importante mencionar que estos parámetros solamente están disponibles si la clase se inicializa con el parámetro <span class="in">`store_covariance`</span> en verdadero.</span>
<span id="cb51-331"><a href="#cb51-331" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-332"><a href="#cb51-332" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-333"><a href="#cb51-333" aria-hidden="true" tabindex="-1"></a><span class="fu">### Predicción {#sec-prediccion}</span></span>
<span id="cb51-334"><a href="#cb51-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-335"><a href="#cb51-335" aria-hidden="true" tabindex="-1"></a>Una vez que se tiene la función que modela los datos, se está en condiciones de utilizarla para predecir (ver @sec-prediccion-normal) nuevos datos. </span>
<span id="cb51-336"><a href="#cb51-336" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-337"><a href="#cb51-337" aria-hidden="true" tabindex="-1"></a>En esta ocasión se organiza el procedimiento de predicción en diferentes funciones, la primera función recibe los datos a predecir <span class="in">`X`</span> y los componentes del modelo, que son la verosimilitud (<span class="in">`likelihood`</span>) y el <span class="in">`prior`</span>. La función calcula $\mathbb P(\mathcal Y=y \mid \mathcal X=x)$ que es la probabilidad de cada clase dada la entrada $x$. Se puede observar en la primera línea que se usa la función de densidad de probabilidad (<span class="in">`pdf`</span>) para cada clase y esta se multiplica por el <span class="in">`prior`</span> y en la tercera línea se calcula la evidencia. Finalmente, se regresa el a posteriori.  </span>
<span id="cb51-338"><a href="#cb51-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-341"><a href="#cb51-341" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-342"><a href="#cb51-342" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-343"><a href="#cb51-343" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict_prob(X, likelihood, prior):</span>
<span id="cb51-344"><a href="#cb51-344" aria-hidden="true" tabindex="-1"></a>    likelihood <span class="op">=</span> [m.pdf(X) <span class="cf">for</span> m <span class="kw">in</span> likelihood]</span>
<span id="cb51-345"><a href="#cb51-345" aria-hidden="true" tabindex="-1"></a>    posterior <span class="op">=</span> np.vstack(likelihood).T <span class="op">*</span> prior</span>
<span id="cb51-346"><a href="#cb51-346" aria-hidden="true" tabindex="-1"></a>    evidence <span class="op">=</span> posterior.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb51-347"><a href="#cb51-347" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> posterior <span class="op">/</span> np.atleast_2d(evidence).T</span>
<span id="cb51-348"><a href="#cb51-348" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-349"><a href="#cb51-349" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-350"><a href="#cb51-350" aria-hidden="true" tabindex="-1"></a>La función <span class="in">`predict_proba`</span> se utiliza como base para predecir la clase, para la cual se requiere el mapa entre índices y clases que se encuentra en la variable <span class="in">`labels`</span>. Se observa que se llama a la función <span class="in">`predict_proba`</span> y después se calcula el argumento que tiene la máxima probabilidad regresando la etiqueta asociada. </span>
<span id="cb51-351"><a href="#cb51-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-354"><a href="#cb51-354" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-355"><a href="#cb51-355" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-356"><a href="#cb51-356" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict(X, likelihood, prior, labels):</span>
<span id="cb51-357"><a href="#cb51-357" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> predict_prob(X, likelihood, prior)</span>
<span id="cb51-358"><a href="#cb51-358" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> labels[np.argmax(_, axis<span class="op">=</span><span class="dv">1</span>)]</span>
<span id="cb51-359"><a href="#cb51-359" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-360"><a href="#cb51-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-361"><a href="#cb51-361" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb51-362"><a href="#cb51-362" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-363"><a href="#cb51-363" aria-hidden="true" tabindex="-1"></a>La predicción en la clase <span class="in">`QuadraticDiscriminantAnalysis`</span> se puede realizar invocando al siguiente método tal y como se muestra en la siguiente linea. </span>
<span id="cb51-366"><a href="#cb51-366" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-367"><a href="#cb51-367" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-368"><a href="#cb51-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-369"><a href="#cb51-369" aria-hidden="true" tabindex="-1"></a>qda_hy <span class="op">=</span> qda.predict(G)</span>
<span id="cb51-370"><a href="#cb51-370" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-371"><a href="#cb51-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-372"><a href="#cb51-372" aria-hidden="true" tabindex="-1"></a>La probabilidad se puede obtener utilizando el método <span class="in">`predict_proba.`</span> </span>
<span id="cb51-373"><a href="#cb51-373" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-376"><a href="#cb51-376" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-377"><a href="#cb51-377" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-378"><a href="#cb51-378" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-379"><a href="#cb51-379" aria-hidden="true" tabindex="-1"></a>qda_prob <span class="op">=</span> qda.predict_proba(G)</span>
<span id="cb51-380"><a href="#cb51-380" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-381"><a href="#cb51-381" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-382"><a href="#cb51-382" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-383"><a href="#cb51-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-384"><a href="#cb51-384" aria-hidden="true" tabindex="-1"></a><span class="fu">### Rendimiento {#sec-rendimiento}</span></span>
<span id="cb51-385"><a href="#cb51-385" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-386"><a href="#cb51-386" aria-hidden="true" tabindex="-1"></a>El rendimiento del algoritmo se mide en el conjunto de prueba <span class="in">`G`</span>, utilizando como medida el error de clasificación (@sec-error-clasificacion). El primer paso es predecir las clases de los elementos en <span class="in">`G`</span>, utilizando la función <span class="in">`predict`</span> que fue diseñada anteriormente. Después se mide el error, con la instrucción de la segunda línea.  </span>
<span id="cb51-387"><a href="#cb51-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-390"><a href="#cb51-390" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-391"><a href="#cb51-391" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-392"><a href="#cb51-392" aria-hidden="true" tabindex="-1"></a>hy <span class="op">=</span> predict(G, likelihood, prior, labels)</span>
<span id="cb51-393"><a href="#cb51-393" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> (y_g <span class="op">!=</span> hy).mean()</span>
<span id="cb51-394"><a href="#cb51-394" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-395"><a href="#cb51-395" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-396"><a href="#cb51-396" aria-hidden="true" tabindex="-1"></a>El error que tiene el algoritmo en el conjunto de prueba es <span class="in">`{python} Markdown(f'${error:0.4f}$')`</span>. </span>
<span id="cb51-397"><a href="#cb51-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-398"><a href="#cb51-398" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb51-399"><a href="#cb51-399" aria-hidden="true" tabindex="-1"></a>El error utilizado <span class="in">`qda_hy`</span> corresponde a <span class="in">`{python} Markdown(f'${(y_g != qda_hy).mean():0.4f}.$')`</span></span>
<span id="cb51-400"><a href="#cb51-400" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-401"><a href="#cb51-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-402"><a href="#cb51-402" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip collapse="true"}</span>
<span id="cb51-403"><a href="#cb51-403" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Actividad</span></span>
<span id="cb51-404"><a href="#cb51-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-405"><a href="#cb51-405" aria-hidden="true" tabindex="-1"></a>Utilizando la probabilidad en el conjunto de prueba, que se tiene en la variable <span class="in">`qda_prob`</span>, calcular la variación del número de elementos que son asociados a la acción nula cuando se varía el nivel de riesgo (ver @sec-seleccion-accion-nula), incluir en la figura o en una figura adicional, la dinámica del error en el conjunto de prueba para los elementos válidos. La @fig-actividad-riesgo-nulo-error muestra el resultado de este proceso. Se observa como van disminuyendo el número de elementos asociados a la acción nula cuando el riesgo se incrementa y al mismo tiempo como el error aumenta.</span>
<span id="cb51-406"><a href="#cb51-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-409"><a href="#cb51-409" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-410"><a href="#cb51-410" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-actividad-riesgo-nulo-error</span></span>
<span id="cb51-411"><a href="#cb51-411" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Variación del número de elementos que seleccionan la acción nula y el error en el conjunto de prueba respecto al riesgo"</span></span>
<span id="cb51-412"><a href="#cb51-412" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-413"><a href="#cb51-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-414"><a href="#cb51-414" aria-hidden="true" tabindex="-1"></a>color<span class="op">=</span>sns.color_palette()</span>
<span id="cb51-415"><a href="#cb51-415" aria-hidden="true" tabindex="-1"></a>riesgo <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">100</span>)</span>
<span id="cb51-416"><a href="#cb51-416" aria-hidden="true" tabindex="-1"></a>masks <span class="op">=</span> [(qda_prob.<span class="bu">max</span>(axis<span class="op">=</span><span class="dv">1</span>) <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">-</span> valor)</span>
<span id="cb51-417"><a href="#cb51-417" aria-hidden="true" tabindex="-1"></a>         <span class="cf">for</span> valor <span class="kw">in</span> riesgo]</span>
<span id="cb51-418"><a href="#cb51-418" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> [mask.shape[<span class="dv">0</span>] <span class="op">-</span> mask.<span class="bu">sum</span>()</span>
<span id="cb51-419"><a href="#cb51-419" aria-hidden="true" tabindex="-1"></a>     <span class="cf">for</span> mask <span class="kw">in</span> masks]</span>
<span id="cb51-420"><a href="#cb51-420" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.lineplot(x<span class="op">=</span>riesgo, y<span class="op">=</span>_, color<span class="op">=</span>color[<span class="dv">0</span>], marker<span class="op">=</span><span class="st">'1'</span>)</span>
<span id="cb51-421"><a href="#cb51-421" aria-hidden="true" tabindex="-1"></a>ax2 <span class="op">=</span> fig.twinx()</span>
<span id="cb51-422"><a href="#cb51-422" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> [<span class="dv">0</span> <span class="cf">if</span> mask.<span class="bu">sum</span>() <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> (y_g[mask] <span class="op">!=</span> qda_hy[mask]).mean()</span>
<span id="cb51-423"><a href="#cb51-423" aria-hidden="true" tabindex="-1"></a>     <span class="cf">for</span> mask <span class="kw">in</span> masks]</span>
<span id="cb51-424"><a href="#cb51-424" aria-hidden="true" tabindex="-1"></a>sns.lineplot(x<span class="op">=</span>riesgo, y<span class="op">=</span>_, ax<span class="op">=</span>ax2, color<span class="op">=</span>color[<span class="dv">1</span>], marker<span class="op">=</span><span class="st">'1'</span>)</span>
<span id="cb51-425"><a href="#cb51-425" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'Error'</span>, color<span class="op">=</span>color[<span class="dv">1</span>])</span>
<span id="cb51-426"><a href="#cb51-426" aria-hidden="true" tabindex="-1"></a>fig.set_xlabel(<span class="st">'Riesgo'</span>)</span>
<span id="cb51-427"><a href="#cb51-427" aria-hidden="true" tabindex="-1"></a>fig.set_yscale(<span class="st">'log'</span>)</span>
<span id="cb51-428"><a href="#cb51-428" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> fig.set_ylabel(<span class="st">'Número de elementos sin predicción'</span>, color<span class="op">=</span>color[<span class="dv">0</span>])</span>
<span id="cb51-429"><a href="#cb51-429" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-430"><a href="#cb51-430" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-431"><a href="#cb51-431" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-432"><a href="#cb51-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-433"><a href="#cb51-433" aria-hidden="true" tabindex="-1"></a>Para calcular el error estándar se utiliza el siguiente código </span>
<span id="cb51-434"><a href="#cb51-434" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-437"><a href="#cb51-437" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-438"><a href="#cb51-438" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-439"><a href="#cb51-439" aria-hidden="true" tabindex="-1"></a>se_formula <span class="op">=</span> np.sqrt(error <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> error) <span class="op">/</span> y_g.shape[<span class="dv">0</span>])</span>
<span id="cb51-440"><a href="#cb51-440" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-441"><a href="#cb51-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-442"><a href="#cb51-442" aria-hidden="true" tabindex="-1"></a>dando un valor de <span class="in">`{python} Markdown(f'${se_formula:0.4f}.$')`</span></span>
<span id="cb51-443"><a href="#cb51-443" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-444"><a href="#cb51-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-445"><a href="#cb51-445" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-446"><a href="#cb51-446" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip collapse="true"}</span>
<span id="cb51-447"><a href="#cb51-447" aria-hidden="true" tabindex="-1"></a><span class="fu">#### Actividad</span></span>
<span id="cb51-448"><a href="#cb51-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-449"><a href="#cb51-449" aria-hidden="true" tabindex="-1"></a>Generar la distribución del error utilizando el método de Bootstrap (ver @sec-bootstrap), tal y como se muestra en la @fig-actividad-distribucion.</span>
<span id="cb51-450"><a href="#cb51-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-453"><a href="#cb51-453" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-454"><a href="#cb51-454" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-actividad-distribucion</span></span>
<span id="cb51-455"><a href="#cb51-455" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Distribución del error"</span></span>
<span id="cb51-456"><a href="#cb51-456" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-457"><a href="#cb51-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-458"><a href="#cb51-458" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> CompStats <span class="im">import</span> performance</span>
<span id="cb51-459"><a href="#cb51-459" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> CompStats <span class="im">import</span> utils</span>
<span id="cb51-460"><a href="#cb51-460" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb51-461"><a href="#cb51-461" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-462"><a href="#cb51-462" aria-hidden="true" tabindex="-1"></a>utils.USE_TQDM <span class="op">=</span> <span class="va">False</span></span>
<span id="cb51-463"><a href="#cb51-463" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(<span class="bu">dict</span>(y<span class="op">=</span>y_g, Estimador<span class="op">=</span>hy))</span>
<span id="cb51-464"><a href="#cb51-464" aria-hidden="true" tabindex="-1"></a>perf <span class="op">=</span> performance(df, score<span class="op">=</span><span class="kw">lambda</span> y, hy: (y <span class="op">!=</span> hy).mean())</span>
<span id="cb51-465"><a href="#cb51-465" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb51-466"><a href="#cb51-466" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.displot(data<span class="op">=</span>perf.calls[<span class="st">'Estimador'</span>], kde<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb51-467"><a href="#cb51-467" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-468"><a href="#cb51-468" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-469"><a href="#cb51-469" aria-hidden="true" tabindex="-1"></a>El error estándar calculado con los datos mostrados en la figura anterior es <span class="in">`{python} Markdown(f'${np.std(perf.calls["Estimador"]):0.4f}$')`</span></span>
<span id="cb51-470"><a href="#cb51-470" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-471"><a href="#cb51-471" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-472"><a href="#cb51-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-473"><a href="#cb51-473" aria-hidden="true" tabindex="-1"></a><span class="fu">## Clasificador Bayesiano Ingenuo {#sec-cl-bayesiano-ingenuo}</span></span>
<span id="cb51-474"><a href="#cb51-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-475"><a href="#cb51-475" aria-hidden="true" tabindex="-1"></a>Uno de los clasificadores mas utilizados, sencillo de implementar y competitivo, es el clasificador Bayesiano Ingenuo. En la @sec-model-clasificacion se asumió que la variable aleatoria $\mathcal X = (\mathcal X_1, \mathcal X_2, \ldots, \mathcal X_d)$ dado $\mathcal Y$ ($\mathcal X_{\mid \mathcal Y}$) es $\mathcal X_{\mid \mathcal Y} \sim \mathcal N(\mu_{\mathcal Y}, \Sigma_{\mathcal Y}),$ donde $\mu_{\mathcal Y} \in \mathbb R^d$, $\Sigma_{\mathcal Y} \in \mathbb R^{d \times d}$ y $f(\mathcal X_1, \mathcal X_2, \ldots, \mathcal X_d)$ es la función de densidad de probabilidad conjunta.</span>
<span id="cb51-476"><a href="#cb51-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-477"><a href="#cb51-477" aria-hidden="true" tabindex="-1"></a>En el clasificador Bayesiano Ingenuo se asume que las variables $\mathcal X_i$ y $\mathcal X_j$ para $i \neq j$ son independientes, esto trae como consecuencia que $f(\mathcal X_1, \mathcal X_2, \ldots, \mathcal X_d) = \prod_i^d f(\mathcal X_i).$ Esto quiere decir que cada variable está definida como una Gausina donde se tiene que identificar $\mu$ y $\sigma^2.$</span>
<span id="cb51-478"><a href="#cb51-478" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-479"><a href="#cb51-479" aria-hidden="true" tabindex="-1"></a>La estimación de los parámetros de estas distribuciones se puede realizar utilizando un código similar siendo la única diferencia que en se calcula $\sigma^2$ de cada variable en lugar de la covarianza $\Sigma$, esto se puede observar en la quinta línea donde se usa la función <span class="in">`np.var`</span> en el primer eje. El resto del código es equivalente al usado en la @sec-estimacion-parametros.</span>
<span id="cb51-480"><a href="#cb51-480" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-483"><a href="#cb51-483" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-484"><a href="#cb51-484" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-485"><a href="#cb51-485" aria-hidden="true" tabindex="-1"></a>likelihood <span class="op">=</span> []</span>
<span id="cb51-486"><a href="#cb51-486" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> k <span class="kw">in</span> labels:</span>
<span id="cb51-487"><a href="#cb51-487" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> y_t <span class="op">==</span> k</span>
<span id="cb51-488"><a href="#cb51-488" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> np.mean(T[mask], axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-489"><a href="#cb51-489" aria-hidden="true" tabindex="-1"></a>    var <span class="op">=</span> np.var(T[mask], axis<span class="op">=</span><span class="dv">0</span>, ddof<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb51-490"><a href="#cb51-490" aria-hidden="true" tabindex="-1"></a>    likelihood_k <span class="op">=</span> multivariate_normal(mean<span class="op">=</span>mu, cov<span class="op">=</span>var)</span>
<span id="cb51-491"><a href="#cb51-491" aria-hidden="true" tabindex="-1"></a>    likelihood.append(likelihood_k)</span>
<span id="cb51-492"><a href="#cb51-492" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-493"><a href="#cb51-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-494"><a href="#cb51-494" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-497"><a href="#cb51-497" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-498"><a href="#cb51-498" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-499"><a href="#cb51-499" aria-hidden="true" tabindex="-1"></a>mus <span class="op">=</span> [<span class="st">', '</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> li.mean]) <span class="cf">for</span> li <span class="kw">in</span> likelihood]</span>
<span id="cb51-500"><a href="#cb51-500" aria-hidden="true" tabindex="-1"></a>mm <span class="op">=</span> []</span>
<span id="cb51-501"><a href="#cb51-501" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> cov <span class="kw">in</span> likelihood:</span>
<span id="cb51-502"><a href="#cb51-502" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> [<span class="st">' &amp; '</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.4f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> reg]) <span class="cf">for</span> reg <span class="kw">in</span> cov.cov]</span>
<span id="cb51-503"><a href="#cb51-503" aria-hidden="true" tabindex="-1"></a>    _ <span class="op">=</span> <span class="st">'</span><span class="ch">\\\\</span><span class="st">'</span>.join(_)</span>
<span id="cb51-504"><a href="#cb51-504" aria-hidden="true" tabindex="-1"></a>    mm.append(_)</span>
<span id="cb51-505"><a href="#cb51-505" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"Los parámetros estimados en la versión ingenua son equivalentes con respecto a las medias, i.e., $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">mu_1 = [</span><span class="sc">{</span>mus[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">]^</span><span class="ch">\\</span><span class="ss">intercal$, $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">mu_2 = [</span><span class="sc">{</span>mus[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">] ^</span><span class="ch">\\</span><span class="ss">intercal$ y $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">mu_3 = [</span><span class="sc">{</span>mus[<span class="dv">2</span>]<span class="sc">}</span><span class="ss">]^</span><span class="ch">\\</span><span class="ss">intercal$. La diferencia se puede observar en las varianzas, que a continuación se muestran como matrices de covarianza para resaltar la diferencia, i.e., $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma_1 = </span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>mm[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">$, $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma_2 = </span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>mm[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">$ y $</span><span class="ch">\\</span><span class="ss">hat </span><span class="ch">\\</span><span class="ss">Sigma_3 = </span><span class="ch">\\</span><span class="ss">begin</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss"> </span><span class="sc">{</span>mm[<span class="dv">2</span>]<span class="sc">}</span><span class="ss"> </span><span class="ch">\\\\</span><span class="ss"> </span><span class="ch">\\</span><span class="ss">end</span><span class="ch">{{</span><span class="ss">pmatrix</span><span class="ch">}}</span><span class="ss">$ se observa como los elementos fuera de la diagonal son ceros, lo cual indica la independencia entra las variables de entrada."</span>)</span>
<span id="cb51-506"><a href="#cb51-506" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-507"><a href="#cb51-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-508"><a href="#cb51-508" aria-hidden="true" tabindex="-1"></a>Finalmente, el código para predecir se utiliza el código descrito en la @sec-prediccion dado que el modelo está dado en las variables <span class="in">`likelihood`</span> y <span class="in">`prior`</span>. </span>
<span id="cb51-509"><a href="#cb51-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-512"><a href="#cb51-512" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-513"><a href="#cb51-513" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-514"><a href="#cb51-514" aria-hidden="true" tabindex="-1"></a>hy_ingenuo <span class="op">=</span> predict(G, likelihood, prior, labels)</span>
<span id="cb51-515"><a href="#cb51-515" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> (y_g <span class="op">!=</span> hy_ingenuo).mean()</span>
<span id="cb51-516"><a href="#cb51-516" aria-hidden="true" tabindex="-1"></a>Markdown(<span class="ss">f"El `error` del clasificador Bayesiano Ingenuo, en el conjunto de prueba, es de $</span><span class="sc">{</span>(y_g <span class="op">!=</span> hy_ingenuo)<span class="sc">.</span>mean()<span class="sc">:0.2f}</span><span class="ss">$ y su error estándar (`se_formula`) es $</span><span class="sc">{</span>np<span class="sc">.</span>sqrt(error <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> error) <span class="op">/</span> y_g.shape[<span class="dv">0</span>])<span class="sc">:0.4f}</span><span class="ss">.$"</span>)</span>
<span id="cb51-517"><a href="#cb51-517" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-518"><a href="#cb51-518" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-519"><a href="#cb51-519" aria-hidden="true" tabindex="-1"></a>::: {.callout-note}</span>
<span id="cb51-520"><a href="#cb51-520" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-521"><a href="#cb51-521" aria-hidden="true" tabindex="-1"></a>El código anterior tiene la finalidad de explicar la estimación de parámetros del Clasificador Bayesiano Ingenuo. Este procedimiento se encuentra en la clase <span class="in">`GaussianNB`</span>, en ese paquete se pueden encontrar implementaciones con otras distribuciones. </span>
<span id="cb51-522"><a href="#cb51-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-523"><a href="#cb51-523" aria-hidden="true" tabindex="-1"></a>El siguiente código muestra su uso. </span>
<span id="cb51-524"><a href="#cb51-524" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-527"><a href="#cb51-527" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-528"><a href="#cb51-528" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-529"><a href="#cb51-529" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-530"><a href="#cb51-530" aria-hidden="true" tabindex="-1"></a>naive <span class="op">=</span> GaussianNB().fit(T, y_t)</span>
<span id="cb51-531"><a href="#cb51-531" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-532"><a href="#cb51-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-533"><a href="#cb51-533" aria-hidden="true" tabindex="-1"></a>Los parámetros $\mu$ se encuentran se pueden consultar con la siguiente instrucción</span>
<span id="cb51-534"><a href="#cb51-534" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-537"><a href="#cb51-537" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-538"><a href="#cb51-538" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-539"><a href="#cb51-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-540"><a href="#cb51-540" aria-hidden="true" tabindex="-1"></a>naive.theta_</span>
<span id="cb51-541"><a href="#cb51-541" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-542"><a href="#cb51-542" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-543"><a href="#cb51-543" aria-hidden="true" tabindex="-1"></a>y $\sigma^2$ en </span>
<span id="cb51-544"><a href="#cb51-544" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-547"><a href="#cb51-547" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-548"><a href="#cb51-548" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-549"><a href="#cb51-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-550"><a href="#cb51-550" aria-hidden="true" tabindex="-1"></a>naive.var_</span>
<span id="cb51-551"><a href="#cb51-551" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-552"><a href="#cb51-552" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-553"><a href="#cb51-553" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb51-554"><a href="#cb51-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-555"><a href="#cb51-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-556"><a href="#cb51-556" aria-hidden="true" tabindex="-1"></a><span class="fu">## Ejemplo: Breast Cancer Wisconsin {#sec-ejemplo-breast-cancer-wisconsin}</span></span>
<span id="cb51-557"><a href="#cb51-557" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-558"><a href="#cb51-558" aria-hidden="true" tabindex="-1"></a>Esta sección ilustra el uso del clasificador Bayesiano al generar dos modelos (Clasificador Bayesiano (mejor conocido como el algoritmo de Análisis Discriminante Cuadrático) y Bayesiano Ingenuo) del conjunto de datos de *Breast Cancer Wisconsin.* Estos datos se pueden obtener utilizando la función <span class="in">`load_breast_cancer`</span> tal y como se muestra a continuación.</span>
<span id="cb51-559"><a href="#cb51-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-562"><a href="#cb51-562" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-563"><a href="#cb51-563" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-564"><a href="#cb51-564" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> load_breast_cancer(return_X_y<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb51-565"><a href="#cb51-565" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-566"><a href="#cb51-566" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-567"><a href="#cb51-567" aria-hidden="true" tabindex="-1"></a>El primer paso es contar con los conjuntos de <span class="co">[</span><span class="ot">entrenamiento y prueba</span><span class="co">](/AprendizajeComputacional/capitulos/03Parametricos/#conjunto-de-entrenamiento-y-prueba)</span> para poder realizar de manera completa la evaluación del proceso de clasificación. Esto se realiza ejecutando la siguiente instrucción.</span>
<span id="cb51-568"><a href="#cb51-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-571"><a href="#cb51-571" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-572"><a href="#cb51-572" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-573"><a href="#cb51-573" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-574"><a href="#cb51-574" aria-hidden="true" tabindex="-1"></a>T, G, y_t, y_g <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb51-575"><a href="#cb51-575" aria-hidden="true" tabindex="-1"></a>                                  random_state<span class="op">=</span>seed)</span>
<span id="cb51-576"><a href="#cb51-576" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-577"><a href="#cb51-577" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-578"><a href="#cb51-578" aria-hidden="true" tabindex="-1"></a><span class="fu">### Entrenamiento</span></span>
<span id="cb51-579"><a href="#cb51-579" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-580"><a href="#cb51-580" aria-hidden="true" tabindex="-1"></a>Los dos modelos que se utilizarán será el clasificador de Análisis Discriminante Cuadrático y Bayesiano Ingenuo, utilizando las clases <span class="in">`QuadraticDiscriminantAnalysis`</span> y <span class="in">`GaussianNB`</span>. Las siguientes dos instrucciones inicializan estos dos clasificadores. </span>
<span id="cb51-581"><a href="#cb51-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-584"><a href="#cb51-584" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-585"><a href="#cb51-585" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-586"><a href="#cb51-586" aria-hidden="true" tabindex="-1"></a>qda <span class="op">=</span> QuadraticDiscriminantAnalysis().fit(T, y_t)</span>
<span id="cb51-587"><a href="#cb51-587" aria-hidden="true" tabindex="-1"></a>naive <span class="op">=</span> GaussianNB().fit(T, y_t)</span>
<span id="cb51-588"><a href="#cb51-588" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-589"><a href="#cb51-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-590"><a href="#cb51-590" aria-hidden="true" tabindex="-1"></a><span class="fu">### Predicción</span></span>
<span id="cb51-591"><a href="#cb51-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-592"><a href="#cb51-592" aria-hidden="true" tabindex="-1"></a>Habiendo definido los dos clasificadores, las predicciones del conjunto de prueba se realiza de la siguiente manera. </span>
<span id="cb51-593"><a href="#cb51-593" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-596"><a href="#cb51-596" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-597"><a href="#cb51-597" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-598"><a href="#cb51-598" aria-hidden="true" tabindex="-1"></a>hy_qda <span class="op">=</span> qda.predict(G)</span>
<span id="cb51-599"><a href="#cb51-599" aria-hidden="true" tabindex="-1"></a>hy_naive <span class="op">=</span> naive.predict(G)</span>
<span id="cb51-600"><a href="#cb51-600" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-601"><a href="#cb51-601" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-602"><a href="#cb51-602" aria-hidden="true" tabindex="-1"></a><span class="fu">### Rendimiento {#sec-gaussina-perf-breast_cancer}</span></span>
<span id="cb51-603"><a href="#cb51-603" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-604"><a href="#cb51-604" aria-hidden="true" tabindex="-1"></a>El rendimiento de ambos clasificadores se calcula de la siguiente manera </span>
<span id="cb51-605"><a href="#cb51-605" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-608"><a href="#cb51-608" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-609"><a href="#cb51-609" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-610"><a href="#cb51-610" aria-hidden="true" tabindex="-1"></a>error_qda <span class="op">=</span> (y_g <span class="op">!=</span> hy_qda).mean()</span>
<span id="cb51-611"><a href="#cb51-611" aria-hidden="true" tabindex="-1"></a>error_naive <span class="op">=</span> (y_g <span class="op">!=</span> hy_naive).mean()</span>
<span id="cb51-612"><a href="#cb51-612" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-613"><a href="#cb51-613" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-614"><a href="#cb51-614" aria-hidden="true" tabindex="-1"></a>El clasificador Bayesiano Gausiano tiene un error de <span class="in">`{python} Markdown(f'${error_qda:0.4f}$')`</span> y el error de Bayesiano Ingenuo es <span class="in">`{python} Markdown(f'${error_naive:0.4f}.$')`</span> Se ha visto que el error es una variable aleatoria, entonces la pregunta es saber si esta diferencia en rendimiento es significativa o es una diferencia que proviene de la aleatoriedad de los datos. </span>
<span id="cb51-615"><a href="#cb51-615" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-616"><a href="#cb51-616" aria-hidden="true" tabindex="-1"></a><span class="fu">## Diferencias en Rendimiento </span></span>
<span id="cb51-617"><a href="#cb51-617" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-618"><a href="#cb51-618" aria-hidden="true" tabindex="-1"></a>Una manera de ver si existe una diferencia en rendimiento es calcular la diferencia entre los dos errores de clasificación, esto es </span>
<span id="cb51-619"><a href="#cb51-619" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-622"><a href="#cb51-622" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-623"><a href="#cb51-623" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-624"><a href="#cb51-624" aria-hidden="true" tabindex="-1"></a>naive <span class="op">=</span> (y_g <span class="op">!=</span> hy_naive).mean()</span>
<span id="cb51-625"><a href="#cb51-625" aria-hidden="true" tabindex="-1"></a>completo <span class="op">=</span> (y_g <span class="op">!=</span> hy_qda).mean()</span>
<span id="cb51-626"><a href="#cb51-626" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> naive <span class="op">&gt;</span> completo:</span>
<span id="cb51-627"><a href="#cb51-627" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> naive <span class="op">-</span> completo</span>
<span id="cb51-628"><a href="#cb51-628" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb51-629"><a href="#cb51-629" aria-hidden="true" tabindex="-1"></a>    diff <span class="op">=</span> completo <span class="op">-</span> naive</span>
<span id="cb51-630"><a href="#cb51-630" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-631"><a href="#cb51-631" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-632"><a href="#cb51-632" aria-hidden="true" tabindex="-1"></a>que tiene un valor de <span class="in">`{python} Markdown(f'${diff:0.4f}$')`</span>. De la misma manera que se ha utilizado la técnica de bootstrap (@sec-bootstrap) para calcular el error estándar de la media, se puede usar para estimar el error estándar de la diferencia en rendimiento. El siguiente código muestra el procedimiento para estimar este error estándar. </span>
<span id="cb51-633"><a href="#cb51-633" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-636"><a href="#cb51-636" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-637"><a href="#cb51-637" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-638"><a href="#cb51-638" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.random.randint(y_g.shape[<span class="dv">0</span>],</span>
<span id="cb51-639"><a href="#cb51-639" aria-hidden="true" tabindex="-1"></a>                      size<span class="op">=</span>(<span class="dv">500</span>, y_g.shape[<span class="dv">0</span>]))</span>
<span id="cb51-640"><a href="#cb51-640" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> naive <span class="op">&gt;</span> completo:</span>
<span id="cb51-641"><a href="#cb51-641" aria-hidden="true" tabindex="-1"></a>    diff_f <span class="op">=</span> <span class="kw">lambda</span> s: (y_g[s] <span class="op">!=</span> hy_naive[s]).mean() <span class="op">-\</span></span>
<span id="cb51-642"><a href="#cb51-642" aria-hidden="true" tabindex="-1"></a>                       (y_g[s] <span class="op">!=</span> hy_qda[s]).mean()</span>
<span id="cb51-643"><a href="#cb51-643" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb51-644"><a href="#cb51-644" aria-hidden="true" tabindex="-1"></a>    diff_f <span class="op">=</span> <span class="kw">lambda</span> s: (y_g[s] <span class="op">!=</span> hy_qda[s]).mean() <span class="op">-\</span></span>
<span id="cb51-645"><a href="#cb51-645" aria-hidden="true" tabindex="-1"></a>                       (y_g[s] <span class="op">!=</span> hy_naive[s]).mean()</span>
<span id="cb51-646"><a href="#cb51-646" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [diff_f(s) <span class="cf">for</span> s <span class="kw">in</span> S]</span>
<span id="cb51-647"><a href="#cb51-647" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(B, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-648"><a href="#cb51-648" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-649"><a href="#cb51-649" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-650"><a href="#cb51-650" aria-hidden="true" tabindex="-1"></a>El error estándar de la diferencia de rendimiento es de <span class="in">`{python} Markdown(f'${se:0.4f}$')`</span>, una procedimiento simple para saber si la diferencia observada es significativa, es dividir la diferencia entre su error estándar dando un valor de <span class="in">`{python} Markdown(f'${diff / se:0.4f}$')`</span>. En el caso que el valor absoluto fuera igual o superior a 2 se sabría que la diferencia es significativa con una confianza de al menos 95%, esto asumiendo que la diferencia se comporta como una distribución Gausiana. </span>
<span id="cb51-651"><a href="#cb51-651" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-652"><a href="#cb51-652" aria-hidden="true" tabindex="-1"></a>El histograma de los datos que se tienen en la variable <span class="in">`B`</span> se observa en la @fig-diff-cl-bayesianos. Se puede ver que la forma del histograma asemeja una distribución Gausiana y que el cero esta en el cuerpo de la Gausiana, tal y como lo confirmó el cociente que se calculado.</span>
<span id="cb51-653"><a href="#cb51-653" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-656"><a href="#cb51-656" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-657"><a href="#cb51-657" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-diff-cl-bayesianos</span></span>
<span id="cb51-658"><a href="#cb51-658" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Diferencia entre Clasificadores Bayesianos</span></span>
<span id="cb51-659"><a href="#cb51-659" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb51-660"><a href="#cb51-660" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb51-661"><a href="#cb51-661" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.displot(B, kde<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb51-662"><a href="#cb51-662" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-663"><a href="#cb51-663" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-664"><a href="#cb51-664" aria-hidden="true" tabindex="-1"></a>Se puede conocer la probabilidad de manera exacta calculando el área bajo la curva a la izquierda del cero, este sería el valor $p$, si este es menor a 0.05 quiere decir que se tiene una confianza mayor del 95% de que los rendimientos son diferentes. Para este ejemplo, el área se calcula con el siguiente código</span>
<span id="cb51-665"><a href="#cb51-665" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-668"><a href="#cb51-668" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-669"><a href="#cb51-669" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-670"><a href="#cb51-670" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> norm(loc<span class="op">=</span>diff, scale<span class="op">=</span>se)</span>
<span id="cb51-671"><a href="#cb51-671" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> dist.cdf(<span class="dv">0</span>)</span>
<span id="cb51-672"><a href="#cb51-672" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-673"><a href="#cb51-673" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-676"><a href="#cb51-676" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-677"><a href="#cb51-677" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-678"><a href="#cb51-678" aria-hidden="true" tabindex="-1"></a>p_value_f <span class="op">=</span> Markdown(<span class="ss">f'$</span><span class="sc">{</span>p_value<span class="sc">:0.4f}</span><span class="ss">$'</span>)</span>
<span id="cb51-679"><a href="#cb51-679" aria-hidden="true" tabindex="-1"></a>conf <span class="op">=</span> Markdown(<span class="ss">f'$</span><span class="sc">{</span><span class="bu">int</span>((<span class="dv">1</span> <span class="op">-</span> p_value) <span class="op">*</span> <span class="dv">100</span>)<span class="sc">}</span><span class="ss">$%'</span>)</span>
<span id="cb51-680"><a href="#cb51-680" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-681"><a href="#cb51-681" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-682"><a href="#cb51-682" aria-hidden="true" tabindex="-1"></a>teniendo el valor de <span class="in">`{python} p_value_f`</span>, lo que significa que se tiene una confianza del <span class="in">`{python} conf`</span> de que los dos algoritmos son diferentes considerando el error de clasificación como medida de rendimiento. </span>
<span id="cb51-683"><a href="#cb51-683" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-684"><a href="#cb51-684" aria-hidden="true" tabindex="-1"></a><span class="fu">## Regresión {#sec-regresion-ols}</span></span>
<span id="cb51-685"><a href="#cb51-685" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-686"><a href="#cb51-686" aria-hidden="true" tabindex="-1"></a>Hasta este momento se han revisado métodos paramétricos en clasificación, ahora es el turno de abordar el problema de regresión. La diferencia entre clasificación y regresión como se describió en la @sec-aprendizaje-supervisado es que en regresión $\mathcal Y \in \mathbb R.$</span>
<span id="cb51-687"><a href="#cb51-687" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-688"><a href="#cb51-688" aria-hidden="true" tabindex="-1"></a>El procedimiento de regresión que se describe en esta sección es regresión de **Mínimos Cuadrados Ordinaria** (OLS -*Ordinary Least Squares*-), en el cual se asume que $\mathcal Y \sim \mathcal N(\mathbf w \cdot \mathbf x + \epsilon, \sigma^2)$, de tal manera que $y = \mathbb E<span class="co">[</span><span class="ot">\mathcal N(\mathbf w \cdot \mathbf x + \epsilon, \sigma^2)</span><span class="co">]</span>.$</span>
<span id="cb51-689"><a href="#cb51-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-690"><a href="#cb51-690" aria-hidden="true" tabindex="-1"></a>Trabajando con $y = \mathbb E<span class="co">[</span><span class="ot">\mathcal N(\mathbf w \cdot \mathbf x + \epsilon, \sigma^2)</span><span class="co">]</span>,$ se considera lo siguiente $y = \mathbb E<span class="co">[</span><span class="ot">\mathcal N(\mathbf w \cdot \mathbf x, 0) + \mathcal N(0, \sigma^2)</span><span class="co">]</span>$ que implica que el error $\epsilon$ es independiente de $\mathbf x$, lo cual se transforma en $y = \mathbf w \cdot \mathbf x + \mathbb E<span class="co">[</span><span class="ot">\epsilon</span><span class="co">]</span>,$ donde $\mathbb E<span class="co">[</span><span class="ot">\epsilon</span><span class="co">]</span>=0.$ Por lo tanto $y = \mathbf w \cdot \mathbf x.$</span>
<span id="cb51-691"><a href="#cb51-691" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-692"><a href="#cb51-692" aria-hidden="true" tabindex="-1"></a>La función de densidad de probabilidad de una Gausiana corresponde a</span>
<span id="cb51-693"><a href="#cb51-693" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-694"><a href="#cb51-694" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-695"><a href="#cb51-695" aria-hidden="true" tabindex="-1"></a>f(\alpha) = \frac{1}{\sigma \sqrt{2 \pi}} \exp{-\frac{1}{2} (\frac{\alpha -  \mu}{\sigma})^2},</span>
<span id="cb51-696"><a href="#cb51-696" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-697"><a href="#cb51-697" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-698"><a href="#cb51-698" aria-hidden="true" tabindex="-1"></a>donde $\alpha$, en el caso de regresión, corresponde a $\mathbf w \cdot \mathbf x$ (i.e., $\alpha = \mathbf w \cdot \mathbf x$).</span>
<span id="cb51-699"><a href="#cb51-699" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-700"><a href="#cb51-700" aria-hidden="true" tabindex="-1"></a>Utilizando el método de verosimilitud el cual corresponde a maximizar </span>
<span id="cb51-701"><a href="#cb51-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-702"><a href="#cb51-702" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-703"><a href="#cb51-703" aria-hidden="true" tabindex="-1"></a>\begin{split}</span>
<span id="cb51-704"><a href="#cb51-704" aria-hidden="true" tabindex="-1"></a>\mathcal L(\mathbf w, \sigma) &amp;= \prod_{(\mathbf x, y) \in \mathcal D} f(\mathbf w \cdot \mathbf x) <span class="sc">\\</span></span>
<span id="cb51-705"><a href="#cb51-705" aria-hidden="true" tabindex="-1"></a>&amp;= \prod_{(\mathbf x, y) \in \mathcal D} \frac{1}{\sigma \sqrt{2\pi}} \exp{(-\frac{1}{2} (\frac{\mathbf w \cdot \mathbf x -  y}{\sigma})^2)} <span class="sc">\\</span></span>
<span id="cb51-706"><a href="#cb51-706" aria-hidden="true" tabindex="-1"></a>\ell(\mathbf w, \sigma) &amp;= \sum_{(\mathbf x, y) \in \mathcal D}\log \frac{1}{\sigma \sqrt{2\pi}}  -\frac{1}{2} (\frac{\mathbf w \cdot \mathbf x -  y}{\sigma})^2 <span class="sc">\\</span></span>
<span id="cb51-707"><a href="#cb51-707" aria-hidden="true" tabindex="-1"></a>&amp;= - \frac{1}{2\sigma^2}  \sum_{(\mathbf x, y) \in \mathcal D} (\mathbf w \cdot \mathbf x -  y)^2 - N \log \frac{1}{\sigma \sqrt{2\pi}}.</span>
<span id="cb51-708"><a href="#cb51-708" aria-hidden="true" tabindex="-1"></a>\end{split}</span>
<span id="cb51-709"><a href="#cb51-709" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-710"><a href="#cb51-710" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-711"><a href="#cb51-711" aria-hidden="true" tabindex="-1"></a>El valor de cada parámetro se obtiene al calcular la derivada parcial con respecto al parámetro de interés, entonces se resuelven $d$ derivadas parciales para cada uno de los coeficientes $\mathbf w$. En este proceso se observar que el término $N \log \frac{1}{\sigma \sqrt{2\pi}}$ no depende de $\mathbf w$ entonces no afecta el máximo siendo una constante en el proceso de derivación y por lo tanto se desprecia. Lo mismo pasa para la constante $\frac{1}{2\sigma^2}$. Una vez obtenidos los parámetros $\mathcal w$ se obtiene el valor $\sigma.$ </span>
<span id="cb51-712"><a href="#cb51-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-713"><a href="#cb51-713" aria-hidden="true" tabindex="-1"></a>Una manera equivalente de plantear este problema es como un problema de algebra lineal, donde se tiene una matriz de observaciones $X$ que se construyen con las variables $\mathbf x$ de $\mathcal X,$ donde cada renglón de $X$ es una observación, y el vector dependiente $\mathbf y$ donde cada elemento es la respuesta correspondiente a la observación.</span>
<span id="cb51-714"><a href="#cb51-714" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-715"><a href="#cb51-715" aria-hidden="true" tabindex="-1"></a>Viéndolo como un problema de algebra lineal lo que se tiene es </span>
<span id="cb51-716"><a href="#cb51-716" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-717"><a href="#cb51-717" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-718"><a href="#cb51-718" aria-hidden="true" tabindex="-1"></a>X \mathbf w = \mathbf y,</span>
<span id="cb51-719"><a href="#cb51-719" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-720"><a href="#cb51-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-721"><a href="#cb51-721" aria-hidden="true" tabindex="-1"></a>donde para identificar $\mathbf w$ se pueden realizar lo siguiente</span>
<span id="cb51-722"><a href="#cb51-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-723"><a href="#cb51-723" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-724"><a href="#cb51-724" aria-hidden="true" tabindex="-1"></a>X^\intercal X \mathbf w = X^\intercal \mathbf y.</span>
<span id="cb51-725"><a href="#cb51-725" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-726"><a href="#cb51-726" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-727"><a href="#cb51-727" aria-hidden="true" tabindex="-1"></a>Despejando $\mathbf w$ se tiene</span>
<span id="cb51-728"><a href="#cb51-728" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-729"><a href="#cb51-729" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-730"><a href="#cb51-730" aria-hidden="true" tabindex="-1"></a>\mathbf w = (X^\intercal X)^{-1} X^\intercal \mathbf y.</span>
<span id="cb51-731"><a href="#cb51-731" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb51-732"><a href="#cb51-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-733"><a href="#cb51-733" aria-hidden="true" tabindex="-1"></a>Previamente se ha presentado el error estándar de cada parámetro que se ha estimado, en caso de la regresión el error estándar (@sec-error-estandar-ols) de $\mathcal w_j$ es $\sigma \sqrt{(X^\intercal X)^{-1}_{jj}}.$</span>
<span id="cb51-734"><a href="#cb51-734" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-735"><a href="#cb51-735" aria-hidden="true" tabindex="-1"></a><span class="fu">### Ejemplo: Diabetes {#sec-diabetes}</span></span>
<span id="cb51-736"><a href="#cb51-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-737"><a href="#cb51-737" aria-hidden="true" tabindex="-1"></a>Esta sección ilustra el proceso de resolver un problema de regresión utilizando OLS. El problema a resolver se obtiene mediante la función <span class="in">`load_diabetes`</span> de la siguiente manera</span>
<span id="cb51-738"><a href="#cb51-738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-741"><a href="#cb51-741" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-742"><a href="#cb51-742" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: True</span></span>
<span id="cb51-743"><a href="#cb51-743" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> load_diabetes(return_X_y<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb51-744"><a href="#cb51-744" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-745"><a href="#cb51-745" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-746"><a href="#cb51-746" aria-hidden="true" tabindex="-1"></a>El siguiente paso es generar los conjuntos de entrenamiento y prueba (@sec-conjunto-entre-prueba)</span>
<span id="cb51-747"><a href="#cb51-747" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-750"><a href="#cb51-750" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-751"><a href="#cb51-751" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-752"><a href="#cb51-752" aria-hidden="true" tabindex="-1"></a>T, G, y_t, y_g <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>,</span>
<span id="cb51-753"><a href="#cb51-753" aria-hidden="true" tabindex="-1"></a>                                  random_state<span class="op">=</span>seed)</span>
<span id="cb51-754"><a href="#cb51-754" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-755"><a href="#cb51-755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-756"><a href="#cb51-756" aria-hidden="true" tabindex="-1"></a>Con el conjunto de entrenamiento <span class="in">`T`</span> y <span class="in">`y_t`</span> se estiman los parámetros de la regresión lineal tal y como se muestra a continuación</span>
<span id="cb51-757"><a href="#cb51-757" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-760"><a href="#cb51-760" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-761"><a href="#cb51-761" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-762"><a href="#cb51-762" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> LinearRegression().fit(T, y_t)</span>
<span id="cb51-763"><a href="#cb51-763" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-764"><a href="#cb51-764" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-767"><a href="#cb51-767" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-768"><a href="#cb51-768" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-769"><a href="#cb51-769" aria-hidden="true" tabindex="-1"></a>w_f <span class="op">=</span> <span class="st">', '</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.2f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> m.coef_[:<span class="dv">3</span>]])</span>
<span id="cb51-770"><a href="#cb51-770" aria-hidden="true" tabindex="-1"></a>w_f <span class="op">=</span> Markdown(<span class="ss">f'$</span><span class="ch">\\</span><span class="ss">mathbf w=[</span><span class="sc">{</span>w_f<span class="sc">}</span><span class="ss">, </span><span class="ch">\\</span><span class="ss">ldots]$'</span>)</span>
<span id="cb51-771"><a href="#cb51-771" aria-hidden="true" tabindex="-1"></a>w_0 <span class="op">=</span> Markdown(<span class="ss">f'$w_0=</span><span class="sc">{</span>m<span class="sc">.</span>intercept_<span class="sc">:0.2f}</span><span class="ss">$'</span>)</span>
<span id="cb51-772"><a href="#cb51-772" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-773"><a href="#cb51-773" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-774"><a href="#cb51-774" aria-hidden="true" tabindex="-1"></a>Los primeros tres coeficientes de la regresión lineal son <span class="in">`{python} w_f`</span> y <span class="in">`{python} w_0`</span> lo cual se encuentran en las siguientes variables</span>
<span id="cb51-775"><a href="#cb51-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-778"><a href="#cb51-778" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-779"><a href="#cb51-779" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-780"><a href="#cb51-780" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> m.coef_</span>
<span id="cb51-781"><a href="#cb51-781" aria-hidden="true" tabindex="-1"></a>w_0 <span class="op">=</span> m.intercept_</span>
<span id="cb51-782"><a href="#cb51-782" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-783"><a href="#cb51-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-784"><a href="#cb51-784" aria-hidden="true" tabindex="-1"></a>La pregunta es si estos coeficientes son estadísticamente diferentes de cero, esto se puede conocer calculando el error estándar de cada coeficiente. Para lo cual se requiere estimar $\sigma$ que corresponde a la desviación estándar del error tal y como se muestra en las siguientes instrucciones.</span>
<span id="cb51-785"><a href="#cb51-785" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-788"><a href="#cb51-788" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-789"><a href="#cb51-789" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-790"><a href="#cb51-790" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> y_t <span class="op">-</span> m.predict(T)</span>
<span id="cb51-791"><a href="#cb51-791" aria-hidden="true" tabindex="-1"></a>std_error <span class="op">=</span> np.std(error)</span>
<span id="cb51-792"><a href="#cb51-792" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-793"><a href="#cb51-793" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-794"><a href="#cb51-794" aria-hidden="true" tabindex="-1"></a>El error estándar de $\mathbf w$ es </span>
<span id="cb51-795"><a href="#cb51-795" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-798"><a href="#cb51-798" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-799"><a href="#cb51-799" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-800"><a href="#cb51-800" aria-hidden="true" tabindex="-1"></a>diag <span class="op">=</span> np.arange(T.shape[<span class="dv">1</span>])</span>
<span id="cb51-801"><a href="#cb51-801" aria-hidden="true" tabindex="-1"></a>_ <span class="op">=</span> np.sqrt((np.dot(T.T, T)<span class="op">**</span>(<span class="op">-</span><span class="dv">1</span>))[diag, diag])</span>
<span id="cb51-802"><a href="#cb51-802" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> std_error <span class="op">*</span> _</span>
<span id="cb51-803"><a href="#cb51-803" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-804"><a href="#cb51-804" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-807"><a href="#cb51-807" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-808"><a href="#cb51-808" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-809"><a href="#cb51-809" aria-hidden="true" tabindex="-1"></a>se_f <span class="op">=</span> <span class="st">', '</span>.join([<span class="ss">f'</span><span class="sc">{</span>v<span class="sc">:0.2f}</span><span class="ss">'</span> <span class="cf">for</span> v <span class="kw">in</span> (w <span class="op">/</span> se)[:<span class="dv">3</span>]])</span>
<span id="cb51-810"><a href="#cb51-810" aria-hidden="true" tabindex="-1"></a>se_f <span class="op">=</span> Markdown(<span class="ss">f'$[</span><span class="sc">{</span>se_f<span class="sc">}</span><span class="ss">, </span><span class="ch">\\</span><span class="ss">ldots]$'</span>)</span>
<span id="cb51-811"><a href="#cb51-811" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-812"><a href="#cb51-812" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-813"><a href="#cb51-813" aria-hidden="true" tabindex="-1"></a>y para saber si los coeficientes son significativamente diferente de cero se calcula el cociente <span class="in">`m.coef_`</span> entre <span class="in">`se`</span>; teniendo los siguientes valores <span class="in">`{python} se_f`</span>, para las tres primeras componentes. Se observa que hay varios coeficientes con valor absoluto menor que 2, lo cual significa que esas variables tiene un coeficiente que estadísticamente no es diferente de cero. </span>
<span id="cb51-814"><a href="#cb51-814" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-815"><a href="#cb51-815" aria-hidden="true" tabindex="-1"></a>La predicción del conjunto de prueba se puede realizar con la siguiente instrucción</span>
<span id="cb51-816"><a href="#cb51-816" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-819"><a href="#cb51-819" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-820"><a href="#cb51-820" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-821"><a href="#cb51-821" aria-hidden="true" tabindex="-1"></a>hy <span class="op">=</span> m.predict(G)</span>
<span id="cb51-822"><a href="#cb51-822" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-823"><a href="#cb51-823" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-824"><a href="#cb51-824" aria-hidden="true" tabindex="-1"></a>Finalmente, la @fig-regresion-lineal-scatter muestra las predicciones contra las mediciones reales. También se incluye la línea que ilustra el modelo ideal. </span>
<span id="cb51-825"><a href="#cb51-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-828"><a href="#cb51-828" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-829"><a href="#cb51-829" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-regresion-lineal-scatter</span></span>
<span id="cb51-830"><a href="#cb51-830" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: Regresión Lineal</span></span>
<span id="cb51-831"><a href="#cb51-831" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb51-832"><a href="#cb51-832" aria-hidden="true" tabindex="-1"></a>sns.scatterplot(x<span class="op">=</span>hy, y<span class="op">=</span>y_g)</span>
<span id="cb51-833"><a href="#cb51-833" aria-hidden="true" tabindex="-1"></a>_min <span class="op">=</span> <span class="bu">min</span>(y_g.<span class="bu">min</span>(), hy.<span class="bu">min</span>())</span>
<span id="cb51-834"><a href="#cb51-834" aria-hidden="true" tabindex="-1"></a>_max <span class="op">=</span> <span class="bu">max</span>(y_g.<span class="bu">max</span>(), hy.<span class="bu">max</span>())</span>
<span id="cb51-835"><a href="#cb51-835" aria-hidden="true" tabindex="-1"></a>sns.set_style(<span class="st">'whitegrid'</span>)</span>
<span id="cb51-836"><a href="#cb51-836" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> sns.lineplot(x<span class="op">=</span>[_min, _max], y<span class="op">=</span>[_min, _max])</span>
<span id="cb51-837"><a href="#cb51-837" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-838"><a href="#cb51-838" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-839"><a href="#cb51-839" aria-hidden="true" tabindex="-1"></a>Complementando el ejemplo anterior, se realiza un modelo que primero elimina las variables que no son estadísticamente diferentes de cero (primera línea) y después crea nuevas variables al incluir el cuadrado, ver las líneas dos y tres del siguiente código. </span>
<span id="cb51-840"><a href="#cb51-840" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-843"><a href="#cb51-843" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-844"><a href="#cb51-844" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-845"><a href="#cb51-845" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> np.fabs(m.coef_ <span class="op">/</span> se) <span class="op">&gt;=</span> <span class="dv">2</span></span>
<span id="cb51-846"><a href="#cb51-846" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> np.concatenate((T[:, mask], T[:, mask]<span class="op">**</span><span class="dv">2</span>), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb51-847"><a href="#cb51-847" aria-hidden="true" tabindex="-1"></a>G <span class="op">=</span> np.concatenate((G[:, mask], G[:, mask]<span class="op">**</span><span class="dv">2</span>), axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb51-848"><a href="#cb51-848" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-849"><a href="#cb51-849" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-850"><a href="#cb51-850" aria-hidden="true" tabindex="-1"></a>Se observa que la identificación de los coeficientes $\mathbf w$ sigue siendo lineal aun y cuando la representación ya no es lineal por incluir el cuadrado. Siguiendo los pasos descritos previamente, se inicializa el modelo y después se realiza la predicción.</span>
<span id="cb51-851"><a href="#cb51-851" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-854"><a href="#cb51-854" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-855"><a href="#cb51-855" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-856"><a href="#cb51-856" aria-hidden="true" tabindex="-1"></a>m2 <span class="op">=</span> LinearRegression().fit(T, y_t)</span>
<span id="cb51-857"><a href="#cb51-857" aria-hidden="true" tabindex="-1"></a>hy2 <span class="op">=</span> m2.predict(G)</span>
<span id="cb51-858"><a href="#cb51-858" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-859"><a href="#cb51-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-862"><a href="#cb51-862" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-863"><a href="#cb51-863" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-864"><a href="#cb51-864" aria-hidden="true" tabindex="-1"></a>diff_f <span class="op">=</span> Markdown(<span class="ss">f'$</span><span class="sc">{</span>((y_g <span class="op">-</span> hy2)<span class="op">**</span><span class="dv">2</span>)<span class="sc">.</span>mean() <span class="op">-</span>  ((y_g <span class="op">-</span> hy)<span class="op">**</span><span class="dv">2</span>)<span class="sc">.</span>mean()<span class="sc">:0.4f}</span><span class="ss">$'</span>)</span>
<span id="cb51-865"><a href="#cb51-865" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-866"><a href="#cb51-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-867"><a href="#cb51-867" aria-hidden="true" tabindex="-1"></a>En este momento se compara si la diferencia entre el error cuadrático medio, del primer y segundo modelo, la diferencia es <span class="in">`{python} diff_f`</span> indicando que el primer modelo es mejor. </span>
<span id="cb51-868"><a href="#cb51-868" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-869"><a href="#cb51-869" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb51-870"><a href="#cb51-870" aria-hidden="true" tabindex="-1"></a>diff <span class="op">=</span> ((y_g <span class="op">-</span> hy2)<span class="op">**</span><span class="dv">2</span>).mean() <span class="op">-</span>  ((y_g <span class="op">-</span> hy)<span class="op">**</span><span class="dv">2</span>).mean()</span>
<span id="cb51-871"><a href="#cb51-871" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-872"><a href="#cb51-872" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-873"><a href="#cb51-873" aria-hidden="true" tabindex="-1"></a>Para comprobar si esta diferencia es significativa se calcula el error estándar, utilizando bootstrap (@sec-bootstrap) tal y como se muestra a continuación. </span>
<span id="cb51-874"><a href="#cb51-874" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-877"><a href="#cb51-877" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-878"><a href="#cb51-878" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-879"><a href="#cb51-879" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> np.random.randint(y_g.shape[<span class="dv">0</span>],</span>
<span id="cb51-880"><a href="#cb51-880" aria-hidden="true" tabindex="-1"></a>                      size<span class="op">=</span>(<span class="dv">500</span>, y_g.shape[<span class="dv">0</span>]))</span>
<span id="cb51-881"><a href="#cb51-881" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [((y_g[s] <span class="op">-</span> hy2[s])<span class="op">**</span><span class="dv">2</span>).mean() <span class="op">-</span></span>
<span id="cb51-882"><a href="#cb51-882" aria-hidden="true" tabindex="-1"></a>      ((y_g[s] <span class="op">-</span> hy[s])<span class="op">**</span><span class="dv">2</span>).mean()</span>
<span id="cb51-883"><a href="#cb51-883" aria-hidden="true" tabindex="-1"></a>     <span class="cf">for</span> s <span class="kw">in</span> S]</span>
<span id="cb51-884"><a href="#cb51-884" aria-hidden="true" tabindex="-1"></a>se <span class="op">=</span> np.std(B, axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb51-885"><a href="#cb51-885" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-886"><a href="#cb51-886" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-889"><a href="#cb51-889" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-890"><a href="#cb51-890" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb51-891"><a href="#cb51-891" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> norm(loc<span class="op">=</span>diff, scale<span class="op">=</span>se)</span>
<span id="cb51-892"><a href="#cb51-892" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> dist.cdf(<span class="dv">0</span>)</span>
<span id="cb51-893"><a href="#cb51-893" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> Markdown(<span class="ss">f'$</span><span class="sc">{</span>p_value<span class="sc">:0.4f}</span><span class="ss">$'</span>)</span>
<span id="cb51-894"><a href="#cb51-894" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb51-895"><a href="#cb51-895" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-896"><a href="#cb51-896" aria-hidden="true" tabindex="-1"></a>Finalmente, se calcula el área bajo la curva a la izquierda del cero, teniendo un valor de <span class="in">`{python} p_value`</span> lo cual indica que los dos modelos son similares. En este caso se prefiere el modelo más simple porque se observar que incluir el cuadrado de las variables no contribuye a generar un mejor model. El área bajo la curva se calcula con el siguiente código. </span>
<span id="cb51-897"><a href="#cb51-897" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-900"><a href="#cb51-900" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb51-901"><a href="#cb51-901" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: true</span></span>
<span id="cb51-902"><a href="#cb51-902" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> norm(loc<span class="op">=</span>diff, scale<span class="op">=</span>se)</span>
<span id="cb51-903"><a href="#cb51-903" aria-hidden="true" tabindex="-1"></a>p_value <span class="op">=</span> dist.cdf(<span class="dv">0</span>)</span>
<span id="cb51-904"><a href="#cb51-904" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
</code><button title="Copiar al portapapeles" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p><a href="http://creativecommons.org/licenses/by-sa/4.0/"><img src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" class="img-fluid"></a> <br> Esta obra está bajo una <a href="http://creativecommons.org/licenses/by-sa/4.0/">Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional</a></p>
</div>
  </div>
</footer>




</body></html>